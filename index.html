<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"queeniechen.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我叫小白，初来乍到，请多指教~">
<meta property="og:type" content="website">
<meta property="og:title" content="Queenie Chen">
<meta property="og:url" content="https://queeniechen.github.io/index.html">
<meta property="og:site_name" content="Queenie Chen">
<meta property="og:description" content="我叫小白，初来乍到，请多指教~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Queenie Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://queeniechen.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Queenie Chen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Queenie Chen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">三十功名尘与土，八千里路云和月</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/06/ImageFormat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/06/ImageFormat/" class="post-title-link" itemprop="url">一张图像的生成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-06 16:00:48" itemprop="dateCreated datePublished" datetime="2020-12-06T16:00:48+08:00">2020-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 00:00:49" itemprop="dateModified" datetime="2020-12-07T00:00:49+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#图像有哪些格式？</p>
<ol>
<li>jpeg</li>
<li>bmp</li>
<li>png</li>
</ol>
<p>注：手机生成的图像格式大多为JPEG</p>
<blockquote>
<blockquote>
<p>YUV：luma(Y)+chroma(UV)格式（亮度、色度），一般情况下sensor支持YUV422格式，即Y-U-Y-V次序输出数据。</p>
</blockquote>
</blockquote>
<pre><code>&gt;&gt;RGB：传统的红绿蓝格式，比如RGB565,5bit R + 6bit G + 5bit B，G多一位是因为人眼对绿色比较敏感。

&gt;&gt;RAW RGB：sensor的每一像素对应一个彩色滤光片，滤光片按Bayer Pattern(拜耳模板)分布，将每一个像素的数据直接输出，即Raw RGB Data。

&gt;&gt;JPEG：有些sensor，特别是低分辨率的，其自带JPEG engine，可以直接输出压缩后的jpg格式的数据。

注意：

a&gt;YUV一个像素占2B，如果像素太大，在高时钟下基带芯片处理不过来，JPEG数据量就要小很多，因为基带芯片对输出数据的速率有要求，所以基带芯片低时钟下使用YUV sensor，高时钟下使用JPEG sensor。

b&gt;如果直接输出RGB，对于LCD显示是最方便的，但是大多数基带芯片都是要求输出为YUV格式的数据再进行，这是因为，YUV输出数据的亮度信号没有任何损失，而色偏信号人眼并不是特别敏感，RGB565输出格式是R5G3 G3B5，会丢失很多原始信息，所以YUV图像质量和稳定性要比RGB565好的多。因此，很低端的基带芯片上才会输出RGB565格式。

Raw和JPEG的区别：

Raw优点：

1&gt;Raw格式文件本质上是一个没有经过任何图像处理的源文件，它能原原本本地记录相机拍摄的信息，没有经过图像处理（锐化、色彩对比增强）和压缩而造成的信息丢失。相比之下，JPEG格式的数据经过压缩处理，无法完整的保存原图形的所有数据。

2&gt;Raw是一种专业摄影师常用的格式，因为它能原原本本地保存信息，让用户能大幅度进行后期制作，并且无论怎么操作，照片都能无损的恢复到最初状态；但是JPEG就弱了些，虽然因为PS等技术的发展，也可以在JPEG上进行后期制作，但是如果做大幅度的调整还是Raw文件比较合适。

3&gt;可以用专门的软件修正摄像机的不足，比如佳能DPP软件可以修正镜头失光、变形等。

Raw缺点：

1&gt;存储数据量太大，JPEG就小很多

2&gt;需要专门的软件来打开，JPEG几乎所有的PC都可以直接打开

3&gt;打开速度较慢，JPEG较快

4&gt;不同的软件有不同的方式去演绎RAW文件，所以在不同的软件上会有细微的差别。

5&gt;厂商卖的专用软件价格较高，而这方面JPEG几乎无成本</code></pre>
<p>##图像采集的过程<br>图像采集的过程为：光照在成像物体被反射 -&gt; 镜头汇聚 -&gt; Sensor光电转换-&gt; ADC转换为raw。</p>
<h3 id="sensor-感光原理"><a href="#sensor-感光原理" class="headerlink" title="sensor 感光原理"></a>sensor 感光原理</h3><ol>
<li>模组<br>摄像头模组，Camera Compact Module，简写为CCM，就是已经包含了镜头，ISP，PCB接口的直接能用的，不需要再考虑sensor选型，设计sensor供电电路，时钟电路的。<br><img src="3.png" alt="img"></li>
</ol>
<p>摄像头模组硬件结构图：<br><img src="4.png" alt="img"></p>
<p>光线通过镜头Lens进入摄像头内部，然后经过IR Filter过滤红外光，最后到达sensor（传感器），<strong>senor分为按照材质可以分为CMOS和CCD两种</strong>，可以将光学信号转换为电信号，再通过内部的ADC电路转换为数字信号，然后传输给DSP（如果有的话，如果没有则以DVP的方式传送数据到基带芯片baseband，此时的数据格式Raw Data，后面有讲进行加工）加工处理，转换成RGB、YUV等格式输出。</p>
<ol start="2">
<li>镜头 Lens：<br>镜头对成像有很重要的作用，相当于人眼中的晶状体，利用透镜的折射原理，景物光线透过镜头在聚焦平面上形成清晰的像，然后通过感光材料CMOS或CCD记录影像，并通过电路转换为电信号。镜头产业有比较高的技术门槛，国外主要集中在日本、韩国，国内主要是在台湾，业内比较知名的如：富士精机、柯尼卡美能达、大力光、Enplas等。</li>
</ol>
<p><img src="7.png" alt="img"><br>Lens一般由几片透镜组成透镜结构，按材质可分为塑胶透镜(plastic)或玻璃透镜(glass)，玻璃镜片比树脂镜片贵。塑胶透镜其实是树脂镜片，透光率和感光性等光学指标比不上镀膜镜片。通常摄像头采用的镜头结构有：1P、2P、1G1P、1G2P、2G2P、2G3P、4G、5G等。透镜越多，成本越高，相对成像效果会更出色（个人理解是光线更均匀、更细致；对光线的选通更丰富；成像畸变更小，但是会导致镜头变长，光通量变小）。</p>
<ol start="3">
<li><p>红外滤光片 IR Filter<br>主要是过滤掉进入镜头的光线中的红外光，这是因为人眼看不到红外光，但是sensor却能感受到红外光，所以需要将光线中的红外光滤掉，以便图像更接近人眼看到的效果。</p>
</li>
<li><p>传感器 Sensor<br>目前常用的sensor有两种，一种是CCD（电荷耦合）原件；一种是CMOS（金属氧化物导体）原件。</p>
</li>
</ol>
<blockquote>
<p>CCD（Charge Coupled Device），电荷耦合器件传感器：使用一种高感光度的半导体材料制成，能把光线转变成电荷，通过模数转换器芯片转换成电信号。CCD由许多独立的感光单位组成，通常以百万像素为单位。<strong>当CCD表面受到光照时，每个感光单位都会将电荷反映在组件上，所有的感光单位产生的信号加在一起，就构成了一幅完整的图像。</strong>CCD传感器以日本厂商为主导，全球市场上有90%被日本厂商垄断，索尼、松下、夏普是龙头。</p>
</blockquote>
<blockquote>
<p>CMOS（Complementary Metal-Oxide Semiconductor），互补性氧化金属半导体：主要是利用硅和锗做成的半导体，使其在CMOS上共存着带N(-)和P(+)级的半导体，这两个互补效应所产生的电流可以被处理芯片记录并解读成影像。CMOS传感器主要以美国、韩国和中国台湾为主导，主要生产厂家是美国的OmnVison、Agilent、Micron，中国台湾的锐像、原相、泰视等，韩国的三星、现代。</p>
</blockquote>
<ol start="5">
<li>图像处理芯片 DSP</li>
</ol>
<p>DSP是CCM的重要组成部分，它的作用是将感光芯片获得的数据及时地快速地传递到中央处理器并刷新感光芯片，因此DSP芯片的好坏，直接影响画面品质，如：色彩饱和度、清晰度、流畅度等。如果sensor没有集成DSP，则通过DVP的方式传输到baseband芯片中（可以理解为外挂DSP），进入DSP的数据是RAW Data，采集到的原始数据。如果集成了DSP，则RAW Data会经过AWB、color matrix、lens shading、gamma、sharpness、AE和de-noise处理，最终输出YUV或者RGB格式的数据。如下图中所示，ISP（Image Sensor Processor，不是Image Signal Processor）部分中使用的就是DSP来处理Image sensor的输出数据（Raw Data）：<br><img src="8.png" alt="img"></p>
<ol start="6">
<li><p>DVP<br>DVP分为三个部分：输出总线；输入总线；电源总线；如下图：<br><img src="9.png" alt="img"></p>
<blockquote>
<blockquote>
<p>输入总线介绍</p>
</blockquote>
</blockquote>
<p> a&gt;PWDN是camera的使能管脚，有两种配置方式，一种为standby，一种是normal work，设置为standby的时候，一切对camera的操作都是无效的，包括复位。所以在RESET之前，一定要将PWDN管脚设置为normal模式，否则RESET无效。</p>
<p> b&gt;RESET是camera的复位管脚，此方式为硬复位模式，camera的各个IO口恢复到出厂默认状态。只有在XCLK开启后，将RESET置为低，硬复位才有效，否则复位无效。</p>
<p> c&gt;XCLK是camera的工作时钟管脚，此管脚为BB提供camera的工作时钟。</p>
<p> d&gt;IIC是camera和BB通信的总线通道。</p>
<blockquote>
<blockquote>
<p>输出总线介绍</p>
</blockquote>
</blockquote>
<p> a&gt;data为camera的数据管脚。此数据脚可以输出的格式有YUV、RGB、JPEG等。</p>
<p> b&gt;VSYNC为camera的帧同步信号管脚。一个VYSNC信号结束表示一帧（即一个画面）的数据已经输出完毕。</p>
<p> c&gt;HSYNC为camera行同步信号管脚。一个HSYNC信号结束表示一行的数据已经输出完毕。</p>
<p> d&gt;PCLK为像素同步信号管脚。一个PCLK信号结束表示一个像素点的数据已经输出完毕。  </p>
<blockquote>
<blockquote>
<p>Power线介绍</p>
</blockquote>
</blockquote>
<p> a&gt;AVDD为camera的模拟电压。</p>
<p> b&gt;DOVDD为camera的GPIO口数字电压。</p>
<p> c&gt;DVDD为camera的核工作电压。<br>一般来说，要求先提供sensor的GPIO口电压，接着提供模拟电压，最后提供工作电压。时序如下图：<br><img src="10.png" alt="img"></p>
</li>
<li><p>FPC柔性电路板(柔性PCB)<br>简称”软板”, 又称”柔性线路板”,连接芯片和手机。起到电信号传输作用。</p>
</li>
<li><p>一些概念区别</p>
<blockquote>
<blockquote>
<p>常见基带处理器或者基带芯片负责数据处理与储存，相当于一个协处理器，主要组件为DSP、微控制器、内存（如SRAM、Flash）等单元，主要功能为基带编码/译码、声音编码及语音编码 等。目前主流基带架构：DSP+ARM。可分为五个子块：CPU处理器、信道编码器、DSP、调制解调器和接口模块。</p>
</blockquote>
</blockquote>
<p> 基带芯片是用来合成即将的发射的基带信号，或对接收到的基带信号进行解码。具体地说，就是：发射时，把音频信号编译成用来发射的基带码；接收时，把收到的基带码解译为音频信号。同时，也负责地址信息（手机号、网站地址）、文字信息（短讯文字、网站文字）、图片信息的编译。</p>
</li>
</ol>
<blockquote>
<blockquote>
<p>ISP，Image Signal Processor，图像信号处理器；DSP，Data Signal Processor，数字信号处理器。</p>
</blockquote>
</blockquote>
<pre><code>ISP一般用来处理Image Sensor（图像传感器）的输出数据，如进行：AEC（自动曝光控制）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Gamma校正、祛除坏点、Auto Black Level、Auto White Level 等等功能的处理。</code></pre>
<blockquote>
<blockquote>
<p>而DSP功能就比较多了，它可以做些拍照以及回显（JPEG的编解码）、录像以及回放（Video 的编解码）、H.264的编解码、还有很多其他方面的处理，总之是处理数字信号了。可以认为ISP是一类特殊的处理图像信号的DSP。</p>
</blockquote>
</blockquote>
<p>在摄像头这部分，要看清楚ISP表示的是什么，是Image Signal Processor（图像信号处理器），还是Image Sensor Processor（图像传感器处理器）。像上面的OV2665里面的ISP就是Image Sensor Processor，相当于Sensor模块中的一部分，由DSP做处理器。而下面的GC0308，则正好相反，是Image Signal Processor，是一个真正的处理器，所以在看到ISP的时候要根据语境看指的是一个具体的处理器还是模块的组成部分。<br><img src="11.png" alt="img"></p>
<ol start="9">
<li><p>图像解析度/分辨率(resolution)</p>
<table>
<thead>
<tr>
<th>QSIF/QQVGA</th>
<th>160 x 120</th>
<th>19200</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>QCIF</td>
<td>176 x 144</td>
<td>25344</td>
<td></td>
</tr>
<tr>
<td>SIF/QVGA</td>
<td>320 x 240</td>
<td>76800</td>
<td></td>
</tr>
<tr>
<td>CIF</td>
<td>352 x 288</td>
<td>101376</td>
<td>10万像素</td>
</tr>
<tr>
<td>VGA</td>
<td>640 x 480</td>
<td>307200</td>
<td>30万像素(35万是指648X488)</td>
</tr>
<tr>
<td>SVGA</td>
<td>800 x 600</td>
<td>480000</td>
<td>50万像素</td>
</tr>
<tr>
<td>XGA</td>
<td>1024 x 768</td>
<td>786438</td>
<td>80万像素</td>
</tr>
<tr>
<td>SXGA</td>
<td>1280 x 1024</td>
<td>1310720</td>
<td>130万像素</td>
</tr>
<tr>
<td>UXGA</td>
<td>1600 x 1200</td>
<td>1920000</td>
<td>200万像素</td>
</tr>
<tr>
<td>QXGA</td>
<td>2048 x 1536</td>
<td>3145728</td>
<td>300万像素(320W)</td>
</tr>
<tr>
<td>QSXGA</td>
<td>2592 x 1944</td>
<td>5038848</td>
<td>500万像素</td>
</tr>
<tr>
<td></td>
<td>2816 x 2112</td>
<td>2947392</td>
<td>600万像素</td>
</tr>
<tr>
<td></td>
<td>3072 x 2304</td>
<td>7077888</td>
<td>700万像素</td>
</tr>
<tr>
<td></td>
<td>3200 x 2400</td>
<td>7680000</td>
<td>770万像素</td>
</tr>
<tr>
<td></td>
<td>3264 x 2448</td>
<td>7990272</td>
<td>800万像素</td>
</tr>
<tr>
<td></td>
<td>3876 x 2584</td>
<td>10015584</td>
<td>1000万像素</td>
</tr>
</tbody></table>
</li>
<li><p>Sensor的感光原理<br>Sensor负责通过一个一个的感光点对光进行采样和量化，但，在Sensor中，每一个感光点只能感光RGB中的一种颜色。所以，通常所说的30万像素或130万像素等，指的是有30万或130万个感光点。<strong>每一个感光点只能感光一种颜色，一个感光点就是一个像素。</strong></p>
</li>
</ol>
<p>因为sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B，形成的数据就成为了raw数据。raw数据是sensor的经过光电转换后通过ADC采样后直接输出数据，是未经处理过的数据，表示sensor接受到的各种光的强度。</p>
<p>解释：sensor上是由一个个感光的小点（你可以这么理解，就是只有几个微米大小的感光器件组成，多少个感光小点就有多少个像素），但是一个像素上要采集多种最基本的颜色，如rgb三种颜色，最简单的方法就是用滤镜的方法，红色的滤镜透过红色的波长，绿色的滤镜透过绿色的波长，蓝色的滤镜透过蓝色的波长。如果要采集rgb三个基本色，则需要三块滤镜，这样价格昂贵，且不好制造，因为三块滤镜都必须保证每一个像素点都对齐显然是不可能的。</p>
<p>所以就有了bayer这种方式，<strong>bayer 格式图片在一块滤镜上设置的不同的颜色，</strong>通过分析人眼对颜色的感知发现，人眼对绿色比较敏感，所以一般bayer格式的图片绿色格式的像素是是r和g像素的和。</p>
<p>Bayer是相机内部的原始图片, 一般后缀名为.raw，bayer图一个像素就只有一个颜色, 或R或G或B。要还原一个真正图像，需要每一个点都有RGB三种颜色。RGB图, 即为三色图, 一个像素点就由RGB三种颜色构成的混合色。</p>
<p>在Sensor模组的内部会有一个ISP模块（应该理解为Image Sensor Processor，是Sensor模块的组成部分，），会对Sensor采集到的数据进行插值和特效处理。如果一个像素点感应为R值，那么ISP会根据该感光点周围的G、B的值，通过插值和特效处理等，计算出该R点的G、B值。</p>
<p>摄像头模组里面干了这个几件事</p>
<p>（1）sensor芯片需要的电源和时钟等信号的设计</p>
<p>（2）有些sensor自己就带内部ISP，或者说集成了，所以输出的直接是YUV或者RGB格式</p>
<p>（3）没有ISP的sensor就需要外部挂一个ISP。电路上就是一个sensor的信号连接到ISP上，信号和传输YUV的这种DVP信号很类似，但是传输的信息是完全不一样的。</p>
<p><img src="5.png" alt="img"></p>
<p>摄像头上有这几个参数，有效像素，和像素尺寸大小：</p>
<p><img src="6.png" alt="img"></p>
<p>对于不同的sensor，在其内部形成的raw数据格式也是有区别的。raw数据排列格式（Bayer pattern）有四种：</p>
<table>
<thead>
<tr>
<th>G</th>
<th>R</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>G</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>G</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>G</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>R</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>B</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>B</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>R</td>
</tr>
</tbody></table>
<p>假设一个sensor的像素是8<em>8（分辨率为8</em>8），那么这个sensor就有8*8个感光点，每个感光点就是一个晶体管。那么对于上表中四种排列格式的rawRGB数据如下图所示：</p>
<p><img src="2.png" alt="img"></p>
<p>由上图可以看出，每一种格式的rawRGB数据的G分量都是B、R分量的两倍，是因为人眼对于绿色的更加敏感，所以加重了其在感光点的权重，增加了对绿色信息的采样。)</p>
<h3 id="摄像头工作原理"><a href="#摄像头工作原理" class="headerlink" title="摄像头工作原理"></a>摄像头工作原理</h3><table>
<thead>
<tr>
<th>Signal</th>
<th>I/O</th>
<th>Description</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>HREF</td>
<td>I</td>
<td>行同步信号</td>
<td></td>
</tr>
<tr>
<td>PCLK</td>
<td>I</td>
<td>像素时钟</td>
<td></td>
</tr>
<tr>
<td>DATA[7:0]</td>
<td>I</td>
<td>像素数据</td>
<td></td>
</tr>
<tr>
<td>FIELD</td>
<td>O</td>
<td>FIELD信号</td>
<td></td>
</tr>
<tr>
<td>MCLK</td>
<td>O</td>
<td>系统时钟信号</td>
<td></td>
</tr>
<tr>
<td>每个摄像头都有三个时钟域，第一个是系统总线时钟域；第二个是摄像头像素时钟域PCLK；第三个是内部时钟MCLK。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>系统总线时钟必须高于PCLK，CAM_MCLK必须固定频率发呢拼比，如：PLL时钟。</p>
<p>一旦给摄像头提供了时钟，并且复位了摄像头，摄像头就可以工作了，通过PCLK、HSYNC、VSYNC听不传输数字图像信号。</p>
<pre><code>摄像头的驱动需要完成三大步：

&gt;&gt;摄像头的上电、时钟这些基本条件

&gt;&gt;IIC保证摄像头的初始化

&gt;&gt;摄像头工作后传回数据到主控</code></pre>
<p><img src="12.png" alt="img"></p>
<p>控制部分是摄像头上电、IIC控制接口；数据输出是摄像头拍摄的图像数据传到主控芯片，所以，需要有Data、行场同步时钟(告诉主控芯片哪些数据是一行，哪些是一帧)、以及时钟（PCLK，像素时钟，告诉主控芯片哪些数据是一个像素点）。<br>（1）、MCLK</p>
<pre><code>摄像头要 工作，必须要有个时钟进行同步，这个时钟就是MCLK，必须要有，否则摄像头就是一个死物，这个时钟由主控芯片提供，确切的说是有主控芯片的控制器提供，下面会提到。</code></pre>
<p>（2）、RESET</p>
<pre><code>复位信号，上面有提</code></pre>
<p>（3）、SDA、SCL</p>
<pre><code>IIC总线，主要作用就是为主控芯片配置或者读取摄像头的寄存器提供通道。mini2440音频模块中的L3协议，也是这个作用。不要看见协议就怕，协议就是一条路，数据传输的路，有规定的数据传输的道路。</code></pre>
<p><img src="13.png" alt="img"></p>
<p>4）、Configuration Register</p>
<pre><code>配置寄存器，控制器（在主控芯片中）通过IIC来设置，相当于告诉摄像头如何工作等。</code></pre>
<p>（5）、Timing Control</p>
<pre><code>时序控制，主要是根据主控芯片提供的MCLK时钟来控制行场同步、自动曝光AEC等。因为这些都需要时钟的配合。</code></pre>
<p>（6）、Pixel Array</p>
<pre><code>gc0308物理上的阵列是648H*492V，实际采样阵列是648H*488V，也是有效阵列。实际取像的阵列是640H*480V。如下图所示：</code></pre>
<p><img src="14.png" alt="img"></p>
<p>（7）、CDS</p>
<pre><code>Correlated Double Sampling，相关双联取样电路。CCD传感器的每个像素点输出波形只在一部分时间内是图像信号，其余时间是复位电平和干扰，为了提取图像信号并消除干扰，就要采用取样保持电路。</code></pre>
<p>（8）、Analog Processing、10bit ADC</p>
<pre><code>主要是将sensor得到的电信号转换为数字信号，方便ISP或者DSP处理。</code></pre>
<p>（9）、Image Signal Processing</p>
<pre><code>图像信号处理器，可以理解为DSP的一种，主要是对sensor经过ADC处理后的Raw Data进行处理，主要有自动白平衡AWB、插值计算（Bayer interpolation主要是对Raw Data进行格式转换，转为YUV /RGB等）、去噪、gamaa修正、色彩修正、边缘增强等。这些都是由寄存器决定，寄存器又是通过IIC总线来设置的。</code></pre>
<p>（10）、Output Mode &amp; Sync Control</p>
<p>** 输出接口，从光线进入镜头、过滤、光感应、ADC，然后到图像数据处理，最终数据到达外部接口。摄像头取一幅图像的整个工作完成，摄像头本质上还是一个终端节点，所以需要将采集好的图像数据传递给主控芯片，所以要有数据引脚，图形格式不是Raw Data，而是YUV或者RGB数据。进行数据传输，肯定需要时钟进行同步，所以需要PCLK，告诉主控芯片，哪个数据代表了一个像素点；VSYNC负责告诉芯片哪些是一帧数据，HSYNC则同步行数据。**</p>
<p>#jpeg文件是如何生成的？</p>
<ol>
<li>首先是要有光学信息。物体自己发光，或者反射光。</li>
<li>sensor(光信号感应器)，将光信号转换为数字信号。<br> input：光信号<br> output：数字信号，格式为raw</li>
<li>raw数据被送往ISP，先转换成RGB，再转换成YUV。</li>
<li>jpeg编码器将ISP输出的YUV数据进行编码压缩，最终输出jpeg文件。</li>
</ol>
<p><img src="1.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/28/power-hint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/power-hint/" class="post-title-link" itemprop="url">power hint机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-28 19:52:50" itemprop="dateCreated datePublished" datetime="2020-11-28T19:52:50+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-30 08:12:16" itemprop="dateModified" datetime="2020-11-30T08:12:16+08:00">2020-11-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>这里camera场景指camera执行的不同阶段，比如open ,preview, take picture.  不同场景对camera性能和功耗要求不一样，比如open时想要快速，必须提频，此时功耗也就高了。如何设置调节策略使得各场景既能达到想要的反应速度，流畅水平，又使得能耗消耗在预期水平？由此引入power hint 机制。</p>
<p>总结一下：性能和功耗平衡需要策略</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>不同的平台软、硬件配置不一样，性能不同，那么策略也有所不同。这里分为3个等级，分别是performance, normal, low power。</p>
<table>
<thead>
<tr>
<th>Power scene</th>
<th>CPU DVFS，</th>
<th>Thermal</th>
<th>DDR DFS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Performance</strong></td>
<td>Generally，at least 4 CPU online &amp; Freq is veryhigh</td>
<td>Disable</td>
<td>Very  high/Normal</td>
</tr>
<tr>
<td><strong>Normal</strong></td>
<td>Default</td>
<td>Enable</td>
<td>Very high/Normal/Low</td>
</tr>
<tr>
<td><strong>Low power</strong></td>
<td>Some  projects have cpu hotplug &amp; Increase the proportion of running low Freq</td>
<td>Enable</td>
<td>Very  high//Normal/Low</td>
</tr>
</tbody></table>
<ol>
<li>performance：<br> 1）通常，至少4个cpu online，cpu freq很高<br> 2）拔核策略disable<br> 3）ddr dfs为high或者normal</li>
<li>normal：<br> 1）cpu频点默认<br> 2）拔核策略enable<br> 3）ddr dfs：high/normal/low</li>
<li>low power：<br> 1)增加跑低频的概率<br> 2)拔核策略enable<br> 3)ddr dfs：high/normal/low</li>
</ol>
<p>##1.1 hal3_2v1<br>对于open camera, close camera, stop preview(flush)，走的都是perforemance等级，ddr dfs走normal即可。</p>
<p>take picture走performance，ddr dfs走high。</p>
<p>recording走low power,ddr dfs也是normal。</p>
<p>普通预览走low power,ddr dfs也是low。</p>
<p>bokeh预览走normal，ddr dfs也是normal。</p>
<table>
<thead>
<tr>
<th>Power scene</th>
<th>CPU DVFS，</th>
<th>Thermal</th>
<th>DDR DFS</th>
<th>Camera  scene</th>
</tr>
</thead>
<tbody><tr>
<td>Performance</td>
<td>Generally，at least 4 CPU online  &amp;  Freq is veryhigh</td>
<td>Disable</td>
<td>normal</td>
<td>Open/close  Camera，stop preview (flush)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Very High</td>
<td>Take  picture</td>
</tr>
<tr>
<td>Normal</td>
<td>Default</td>
<td>Enable</td>
<td>Normal</td>
<td>Preview  with Blu /Bokeh/Panorama</td>
</tr>
<tr>
<td>Low power</td>
<td>Some  projects have cpu hotplug /Increase the proportion of running low Freq</td>
<td>Enable</td>
<td>Normal</td>
<td>Recording</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Low</td>
<td>preview  under normal scene</td>
</tr>
</tbody></table>
<p><img src="1.png" alt="img"></p>
<p>##1.2 hal3_2v4</p>
<table>
<thead>
<tr>
<th>Power scene</th>
<th>CPU DVFS，</th>
<th>DDR DFS</th>
<th>Camera  scene</th>
</tr>
</thead>
<tbody><tr>
<td>Performance</td>
<td>Generally，at least 4 CPU online  &amp;  Freq is veryhigh</td>
<td>Normal（as default is Very high）</td>
<td>Open /close  Camera，</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Very high</td>
<td>Take  picture</td>
</tr>
<tr>
<td>Normal</td>
<td>Default</td>
<td>Normal （as default is Very high）</td>
<td>NULL</td>
</tr>
<tr>
<td>Low power</td>
<td>Just  Increase the proportion of running low Freq</td>
<td>Very high</td>
<td>Preview /  recording</td>
</tr>
</tbody></table>
<p><img src="2.png" alt="img"></p>
<h1 id="2-如何实现？"><a href="#2-如何实现？" class="headerlink" title="2. 如何实现？"></a>2. 如何实现？</h1><h2 id="2-1-怎么选择策略？"><a href="#2-1-怎么选择策略？" class="headerlink" title="2.1 怎么选择策略？"></a>2.1 怎么选择策略？</h2><p>各场景根据需要从如下的结构体中选择对应的策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef enum CAMERA_PERFORMACE_SCENE &#123;</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_1 &#x3D; 1,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_2,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_3,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_4,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_5,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_6,</span><br><span class="line">    CAM_PERFORMNCE_LEVEL_MAX</span><br><span class="line">&#125; sys_performance_camera_scene;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-setCamPreformaceScene"><a href="#2-1-1-setCamPreformaceScene" class="headerlink" title="2.1.1 setCamPreformaceScene"></a>2.1.1 setCamPreformaceScene</h3><p>问题来了，谁来选这个策略？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void SprdCameraSystemPerformance::setCamPreformaceScene(</span><br><span class="line">    sys_performance_camera_scene camera_scene) &#123;</span><br><span class="line">    Mutex::Autolock l(&amp;mLock);</span><br><span class="line">#ifndef CONFIG_CAMERA_DFS_FIXED_MAXLEVEL</span><br><span class="line">    switch (camera_scene) &#123;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_6:</span><br><span class="line">        setPowerHint(CAM_POWER_PERFORMACE_ON);</span><br><span class="line">        changeDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_5:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_4:</span><br><span class="line">        setPowerHint(CAM_POWER_NORMAL);</span><br><span class="line">        changeDfsPolicy(CAM_NORMAL);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_3:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_2:</span><br><span class="line">        setPowerHint(CAM_POWER_LOWPOWER_ON);</span><br><span class="line">        changeDfsPolicy(CAM_NORMAL);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_1:</span><br><span class="line">        setPowerHint(CAM_POWER_LOWPOWER_ON);</span><br><span class="line">        changeDfsPolicy(CAM_LOW);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGI(&quot;camera scene not support&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">#if (CONFIG_CAMERA_DFS_FIXED_MAXLEVEL &#x3D;&#x3D; 3)</span><br><span class="line">    changeDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">#elif(CONFIG_CAMERA_DFS_FIXED_MAXLEVEL &#x3D;&#x3D; 2)</span><br><span class="line">    changeDfsPolicy(CAM_NORMAL);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    switch (camera_scene) &#123;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_6:</span><br><span class="line">        setPowerHint(CAM_POWER_PERFORMACE_ON);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_5:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_4:</span><br><span class="line">        setPowerHint(CAM_POWER_NORMAL);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_3:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_2:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_1:</span><br><span class="line">        setPowerHint(CAM_POWER_LOWPOWER_ON);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGI(&quot;camera scene not support&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    mCurrentPowerHintScene &#x3D; camera_scene;</span><br><span class="line"></span><br><span class="line">    HAL_LOGD(&quot;x camera scene:%d&quot;, camera_scene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又有2个问题，通过给函数setCamPreformaceScene传入具体参数camera_scene来选择策略，那么</p>
<ol>
<li>选择策略后，又是如何实现策略实施的呢？</li>
<li>谁给setCamPreformaceScene传的这个参数？</li>
</ol>
<h2 id="2-2-策略如何实施？"><a href="#2-2-策略如何实施？" class="headerlink" title="2.2 策略如何实施？"></a>2.2 策略如何实施？</h2><p>在setCamPreformaceScene这个函数体的实现中可以看到，根据不同配置有不同的策略方案。主要是：</p>
<ol>
<li>int SprdCameraSystemPerformance::changeDfsPolicy(dfs_policy_t dfs_policy)这个是来选择ddr dfs策略的</li>
<li>void SprdCameraSystemPerformance::setPowerHint(power_hint_state_type_t powerhint_id)这个是设置power hint的等级的</li>
</ol>
<p>ddr dfs等级结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum DFS_POLICY &#123;</span><br><span class="line">    CAM_EXIT,</span><br><span class="line">    CAM_LOW,</span><br><span class="line">    CAM_NORMAL,</span><br><span class="line">    CAM_VERYHIGH,</span><br><span class="line">&#125; dfs_policy_t;</span><br></pre></td></tr></table></figure>

<p>power scene结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef enum CURRENT_POWER_HINT &#123;</span><br><span class="line">    CAM_POWER_NORMAL,</span><br><span class="line">    CAM_POWER_PERFORMACE_ON,</span><br><span class="line">    CAM_POWER_PERFORMACE_ON</span><br><span class="line">&#125; power_hint_state_type_t;</span><br></pre></td></tr></table></figure>
<p>现在结构体是不是有点混乱？我们来理一理：<br>power_hint_state_type_t总共3个档次，对应之前说的NORMAL，PERFORMACE和PERFORMACE这3种策略。从表格中可以看出，不同的camera scene除了要选刚刚3种策略外，还要选中ddr dfs策略（这里dfs_policy_t有4档）。所以，由于cpu dvfs和ddr dfs都要选中，于是sys_performance_camera_scene就配出了多个来，这里是7个。实际代码实现顺序是先传camera_scene这个参数，再去适配cpu dvfs和ddr dfs。</p>
<h3 id="2-2-1-changeDfsPolicy"><a href="#2-2-1-changeDfsPolicy" class="headerlink" title="2.2.1 changeDfsPolicy"></a>2.2.1 changeDfsPolicy</h3><p>changeDfsPolicy这个函数是用来实现dfs_policy的选择的，当dfs_policy为CAM_EXIT时，根据当前dfs策略进行releaseDfsPolicy（mCameraDfsPolicyCur），设置完后将mCameraDfsPolicyCur = CAM_EXIT；当dfs_policyCAM_LOW时，setDfsPolicy（CAM_LOW），并且根据当前mCameraDfsPolicyCur来选择releaseDfsPolicy（）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">int SprdCameraSystemPerformance::changeDfsPolicy(dfs_policy_t dfs_policy) &#123;</span><br><span class="line"></span><br><span class="line">    switch (dfs_policy) &#123;</span><br><span class="line">    case CAM_EXIT:</span><br><span class="line">        if (CAM_LOW &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            releaseDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_NORMAL &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            releaseDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125; else if (CAM_VERYHIGH &#x3D;&#x3D; mCameraDfsPolicyCur)</span><br><span class="line">            releaseDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_EXIT;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_LOW:</span><br><span class="line">        if (CAM_EXIT &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_NORMAL &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_LOW);</span><br><span class="line">            releaseDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125; else if (CAM_VERYHIGH &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_LOW);</span><br><span class="line">            releaseDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        &#125;</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_LOW;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_NORMAL:</span><br><span class="line">        if (CAM_EXIT &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125; else if (CAM_LOW &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_NORMAL);</span><br><span class="line">            releaseDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_VERYHIGH &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_NORMAL);</span><br><span class="line">            releaseDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        &#125;</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_NORMAL;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_VERYHIGH:</span><br><span class="line">        if (CAM_EXIT &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        &#125; else if (CAM_LOW &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">            releaseDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_NORMAL &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">            releaseDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_VERYHIGH;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGW(&quot;unrecognize dfs policy&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;mCameraDfsPolicyCur: %d&quot;, mCameraDfsPolicyCur);</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-1-releaseDfsPolicy"><a href="#2-2-1-1-releaseDfsPolicy" class="headerlink" title="2.2.1.1 releaseDfsPolicy"></a>2.2.1.1 releaseDfsPolicy</h4><p>在releaseDfsPolicy（）这个函数里，根据不同的dfs_policy，设置dfs_scene值，并将其写入文件节点exit_scene</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int SprdCameraSystemPerformance::releaseDfsPolicy(int dfs_policy) &#123;</span><br><span class="line"></span><br><span class="line">    const char *dfs_scene &#x3D; NULL;</span><br><span class="line">    const char *const scenario_dfs &#x3D;</span><br><span class="line">        &quot;&#x2F;sys&#x2F;class&#x2F;devfreq&#x2F;scene-frequency&#x2F;sprd_governor&#x2F;exit_scene&quot;;</span><br><span class="line">    FILE *fp &#x3D; fopen(scenario_dfs, &quot;wb&quot;);</span><br><span class="line">    if (NULL &#x3D;&#x3D; fp) &#123;</span><br><span class="line">        HAL_LOGW(&quot;failed to open %s X&quot;, scenario_dfs);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (dfs_policy) &#123;</span><br><span class="line">    case CAM_LOW:</span><br><span class="line">        dfs_scene &#x3D; CAM_LOW_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_NORMAL:</span><br><span class="line">        dfs_scene &#x3D; CAM_NORMAL_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_VERYHIGH:</span><br><span class="line">        dfs_scene &#x3D; CAM_VERYHIGH_STR;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGW(&quot;unrecognize dfs policy&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;release dfs_scene: %s&quot;, dfs_scene);</span><br><span class="line">    &#x2F;&#x2F; echo dfs_scene &gt; scenario_dfs</span><br><span class="line">    fprintf(fp, &quot;%s&quot;, dfs_scene);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp &#x3D; NULL;</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-2-setDfsPolicy"><a href="#2-2-1-2-setDfsPolicy" class="headerlink" title="2.2.1.2 setDfsPolicy"></a>2.2.1.2 setDfsPolicy</h4><p>在 setDfsPolicy（）这个函数里，根据不同的dfs_policy，设置dfs_scene值，并将其写入文件节点scenario_dfs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int SprdCameraSystemPerformance::setDfsPolicy(int dfs_policy) &#123;</span><br><span class="line"></span><br><span class="line">    const char *dfs_scene &#x3D; NULL;</span><br><span class="line">    const char *const scenario_dfs &#x3D;</span><br><span class="line">        &quot;&#x2F;sys&#x2F;class&#x2F;devfreq&#x2F;scene-frequency&#x2F;sprd_governor&#x2F;scenario_dfs&quot;;</span><br><span class="line">    FILE *fp &#x3D; fopen(scenario_dfs, &quot;wb&quot;);</span><br><span class="line">    if (NULL &#x3D;&#x3D; fp) &#123;</span><br><span class="line">        HAL_LOGW(&quot;failed to open %s X&quot;, scenario_dfs);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (dfs_policy) &#123;</span><br><span class="line">    case CAM_LOW:</span><br><span class="line">        dfs_scene &#x3D; CAM_LOW_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_NORMAL:</span><br><span class="line">        dfs_scene &#x3D; CAM_NORMAL_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_VERYHIGH:</span><br><span class="line">        dfs_scene &#x3D; CAM_VERYHIGH_STR;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGW(&quot;unrecognize dfs policy&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;dfs_scene: %s&quot;, dfs_scene);</span><br><span class="line">    &#x2F;&#x2F; echo dfs_scene &gt; scenario_dfs</span><br><span class="line">    fprintf(fp, &quot;%s&quot;, dfs_scene);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-setPowerHint"><a href="#2-2-2-setPowerHint" class="headerlink" title="2.2.2 setPowerHint"></a>2.2.2 setPowerHint</h3><p>setPowerHint函数的实现，首先要考虑和判断当前powerhint策略。例如要设置成CAM_POWER_PERFORMACE_ON，而当前已经是CAM_POWER_PERFORMACE_ON了，就无需多做什么了。若当前策略为CAM_POWER_NORMAL，而目标等级CAM_POWER_PERFORMACE_ON，则</p>
<p>1）acquirePowerHint</p>
<p>2）重新设置mCurrentPowerHint</p>
<p>当前策略不是CAM_POWER_NORMAL时，而策略有变化时，需要先releasePowerHint当前策略，再获取策略，置状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void SprdCameraSystemPerformance::setPowerHint(</span><br><span class="line">    power_hint_state_type_t powerhint_id) &#123;</span><br><span class="line"></span><br><span class="line">    if (!mPowermanageInited) &#123;</span><br><span class="line">        HAL_LOGE(&quot;need init.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;IN, mCurrentPowerHint&#x3D;%d&quot;, mCurrentPowerHint);</span><br><span class="line"></span><br><span class="line">#if (CONFIG_HAS_CAMERA_HINTS_VERSION &#x3D;&#x3D; ANDROID_VERSION_P)</span><br><span class="line">    switch (mCurrentPowerHint) &#123;</span><br><span class="line">    case CAM_POWER_NORMAL:</span><br><span class="line">        if (powerhint_id &#x3D;&#x3D; CAM_POWER_PERFORMACE_ON) &#123;</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(false);</span><br><span class="line">            acquirePowerHint(mScenePerformance);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_PERFORMACE_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_LOWPOWER_ON) &#123;</span><br><span class="line">            acquirePowerHint(mSceneLowPower);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_LOWPOWER_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_NORMAL) &#123;</span><br><span class="line">            HAL_LOGD(&quot;current power state is already CAM_POWER_NORMAL,&quot;</span><br><span class="line">                     &quot;state are both 0, just return&quot;);</span><br><span class="line">            goto exit;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_POWER_PERFORMACE_ON:</span><br><span class="line">        if (powerhint_id &#x3D;&#x3D; CAM_POWER_PERFORMACE_ON) &#123;</span><br><span class="line">            HAL_LOGD(&quot;current power state is already CAM_POWER_PERFORMACE_ON,&quot;</span><br><span class="line">                     &quot;state are both 1, just return&quot;);</span><br><span class="line">            goto exit;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_LOWPOWER_ON) &#123;</span><br><span class="line">            releasePowerHint(mScenePerformance);</span><br><span class="line">            acquirePowerHint(mSceneLowPower);</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(true);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_LOWPOWER_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_NORMAL) &#123;</span><br><span class="line">            releasePowerHint(mScenePerformance);</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(true);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_NORMAL;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_POWER_LOWPOWER_ON:</span><br><span class="line">        if (powerhint_id &#x3D;&#x3D; CAM_POWER_PERFORMACE_ON) &#123;</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(false);</span><br><span class="line">            releasePowerHint(mSceneLowPower);</span><br><span class="line">            acquirePowerHint(mScenePerformance);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_PERFORMACE_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_LOWPOWER_ON) &#123;</span><br><span class="line">            HAL_LOGD(&quot;current power state is already CAM_POWER_LOWPOWER_ON,&quot;</span><br><span class="line">                     &quot;state are both 0, just return&quot;);</span><br><span class="line">            goto exit;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_NORMAL) &#123;</span><br><span class="line">            releasePowerHint(mSceneLowPower);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_NORMAL;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGE(&quot;should not be here&quot;);</span><br><span class="line">        goto exit;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">exit:</span><br><span class="line">    HAL_LOGD(&quot;out, mCurrentPowerHint&#x3D;%d&quot;, mCurrentPowerHint);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-1acquirePowerHint"><a href="#2-2-2-1acquirePowerHint" class="headerlink" title="2.2.2.1acquirePowerHint"></a>2.2.2.1acquirePowerHint</h4><p>acquirePowerHint主要由acquire()实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if (CONFIG_HAS_CAMERA_HINTS_VERSION &#x3D;&#x3D; ANDROID_VERSION_P)</span><br><span class="line">void SprdCameraSystemPerformance::acquirePowerHint(</span><br><span class="line">    ::android::sp&lt;::android::PowerHintScene&gt; mScene) &#123;</span><br><span class="line"></span><br><span class="line">    if (mScene !&#x3D; NULL) &#123;</span><br><span class="line">        mScene-&gt;acquire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-2-releasePowerHint"><a href="#2-2-2-2-releasePowerHint" class="headerlink" title="2.2.2.2 releasePowerHint"></a>2.2.2.2 releasePowerHint</h4><p>releasePowerHint主要由release()实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void SprdCameraSystemPerformance::releasePowerHint(</span><br><span class="line">    ::android::sp&lt;::android::PowerHintScene&gt; mScene) &#123;</span><br><span class="line"></span><br><span class="line">    if (mScene !&#x3D; NULL) &#123;</span><br><span class="line">        mScene-&gt;release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="谁来选择策略？"><a href="#谁来选择策略？" class="headerlink" title="谁来选择策略？"></a>谁来选择策略？</h2><p>我们来看看哪些地方调用了setCamPreformaceScene：</p>
<ol>
<li><p>关闭相机的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SprdCamera3HWI::closeCamera() &#123;</span><br><span class="line">mOEMIf-&gt;setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>切换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int SprdCamera3HWI::flush() &#123;</span><br><span class="line">    if (mOEMIf) &#123;</span><br><span class="line">        mOEMIf-&gt;setFlushFlag(1);</span><br><span class="line">        mOEMIf-&gt;setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int SprdCamera3OEMIf::start(camera_channel_type_t channel_type,</span><br><span class="line">                            uint32_t frame_number) &#123;</span><br><span class="line">	setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动对焦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t SprdCamera3OEMIf::autoFocus() &#123;</span><br><span class="line">    if (mSysPerformace) &#123;</span><br><span class="line">        mGetLastPowerHint &#x3D; mSysPerformace-&gt;mCurrentPowerHintScene;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收预览帧时，根据预览流，当时的模式选择不同的档次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void SprdCamera3OEMIf::receivePreviewFrame(struct camera_frame_type *frame) &#123;</span><br><span class="line">	if (pre_stream) &#123;</span><br><span class="line">		if (!isCapturing() &amp;&amp; mIsPowerhintWait &amp;&amp; !mIsAutoFocus) &#123;</span><br><span class="line">			if ((frame_num &gt; mStartFrameNum) &amp;&amp;(frame_num - 						mStartFrameNum &gt; CAM_POWERHINT_WAIT_COUNT)) &#123;</span><br><span class="line">				if (getMultiCameraMode() &#x3D;&#x3D; MODE_BLUR ||</span><br><span class="line">                    getMultiCameraMode() &#x3D;&#x3D; MODE_BOKEH ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_PANORAMA ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_3DNR_PHOTO ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_FILTER ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; -1 ||</span><br><span class="line">                    (mRecordingMode &amp;&amp; !mVideoWidth &amp;&amp; !mVideoHeight))&#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_4);</span><br><span class="line">				&#125; else if (mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_CONTINUE ||</span><br><span class="line">                           sprddefInfo-&gt;slowmotion &gt; 1) &#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);&#x2F;&#x2F;</span><br><span class="line">				&#125; else if (mRecordingMode &#x3D;&#x3D; true) &#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_3);&#x2F;&#x2F;录像模式</span><br><span class="line">				&#125; else if (getMultiCameraMode() !&#x3D; 											MODE_SINGLE_FACEID_UNLOCK) &#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_1);</span><br><span class="line">                &#125;</span><br><span class="line">                mIsPowerhintWait &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接收jpeg图片时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void SprdCamera3OEMIf::receiveJpegPicture(struct camera_frame_type *frame) &#123;</span><br><span class="line">    if (getMultiCameraMode() &#x3D;&#x3D; MODE_BLUR ||</span><br><span class="line">        getMultiCameraMode() &#x3D;&#x3D; MODE_BOKEH ||</span><br><span class="line">        mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_3DNR_PHOTO) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_4);</span><br><span class="line">    &#125; else if (mRecordingMode &#x3D;&#x3D; true) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_3);</span><br><span class="line">    &#125; else if (mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_CONTINUE) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void SprdCamera3OEMIf::HandleFocus(enum camera_cb_type cb, void *parm4) &#123;</span><br><span class="line">switch (cb) &#123;</span><br><span class="line">    case CAMERA_EXIT_CB_DONE:</span><br><span class="line">        HAL_LOGV(&quot;camera cb: autofocus succeeded.&quot;);</span><br><span class="line">        &#123;</span><br><span class="line">            if (mIsAutoFocus) &#123;</span><br><span class="line">                setCamPreformaceScene(mGetLastPowerHint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    case CAMERA_EXIT_CB_FAILED: &#123;</span><br><span class="line">        if (mIsAutoFocus) &#123;</span><br><span class="line">            setCamPreformaceScene(mGetLastPowerHint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SprdCamera3OEMIf::SprdCamera3OEMIf(int cameraId, SprdCamera3Setting *setting)</span><br><span class="line">    : mSetCapRatioFlag(false), mVideoCopyFromPreviewFlag(false),</span><br><span class="line">      mSprdPipVivEnabled(0), mSprdHighIsoEnabled(0), mSprdFullscanEnabled(0),</span><br><span class="line">      mSprdRefocusEnabled(0), mSprd3dCalibrationEnabled(0), mSprdYuvCallBack(0),</span><br><span class="line">      mSprdMultiYuvCallBack(0), mSprdReprocessing(0), mNeededTimestamp(0),</span><br><span class="line">      mIsUnpopped(false), mIsBlur2Zsl(false),</span><br><span class="line">      mPreviewFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mVideoFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mCallbackFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mPictureFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mRawFormat(CAM_IMG_FMT_BAYER_MIPI_RAW), mPreviewStartFlag(0),</span><br><span class="line">      mIsDvPreview(0), mIsStoppingPreview(0), mRecordingMode(0),</span><br><span class="line">      mIsSetCaptureMode(false), mRecordingFirstFrameTime(0), mUser(0),</span><br><span class="line">      mPreviewWindow(NULL), mHalOem(NULL), mIsStoreMetaData(false),</span><br><span class="line">      mIsFreqChanged(false), mCameraId(cameraId), miSPreviewFirstFrame(1),</span><br><span class="line">      mCaptureMode(CAMERA_NORMAL_MODE), mCaptureRawMode(0), mFlashMask(false),</span><br><span class="line">      mReleaseFLag(false), mTimeCoeff(1), mIsPerformanceTestable(false),</span><br><span class="line">      mIsAndroidZSL(false), mSetting(setting), BurstCapCnt(0), mCapIntent(0),</span><br><span class="line">      mPrvTimerID(NULL), mFlashMode(-1), mIsAutoFocus(false),</span><br><span class="line">      mIspToolStart(false), mSubRawHeapNum(0), mGraphicBufNum(0), mEisGraphicBufNum(0),</span><br><span class="line">      mSubRawHeapSize(0), mPathRawHeapNum(0), mPathRawHeapSize(0),</span><br><span class="line">      mPreviewDcamAllocBufferCnt(0), mIsRecording(false),</span><br><span class="line">      mZSLModeMonitorMsgQueHandle(0), mZSLModeMonitorInited(0), mCNRMode(0),</span><br><span class="line">      mGyroInit(0), mGyroExit(0), mEisPreviewInit(false), mEisVideoInit(false),</span><br><span class="line">      mGyroNum(0), mSprdEisEnabled(false), mVideoSnapshotType(0),</span><br><span class="line">      mIommuEnabled(false), mFlashCaptureFlag(0),</span><br><span class="line">      mFlashCaptureSkipNum(FLASH_CAPTURE_SKIP_FRAME_NUM), mFixedFpsEnabled(0),</span><br><span class="line">      mSprdAppmodeId(-1), mTempStates(CAMERA_NORMAL_TEMP), mIsTempChanged(0),</span><br><span class="line">      mFlagOffLineZslStart(0), mZslSnapshotTime(0), mIsIspToolMode(0),</span><br><span class="line">      mIsUltraWideMode(false), mIsRawCapture(0), mIsCameraClearQBuf(0),</span><br><span class="line">      mLatestFocusDoneTime(0), mFaceDetectStartedFlag(0),</span><br><span class="line">      mIsJpegWithBigSizePreview(0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    SprdCameraSystemPerformance::getSysPerformance(&amp;mSysPerformace);</span><br><span class="line">    if (mSysPerformace) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/22/gcov/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/gcov/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-22 23:14:52 / 修改时间：23:32:06" itemprop="dateCreated datePublished" datetime="2020-11-22T23:14:52+08:00">2020-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h2 id="title-gcov代码覆盖率测试"><a href="#title-gcov代码覆盖率测试" class="headerlink" title="title:gcov代码覆盖率测试"></a>title:gcov代码覆盖率测试</h2><h1 id="GCOV是什么？"><a href="#GCOV是什么？" class="headerlink" title="GCOV是什么？"></a>GCOV是什么？</h1><p>Gcov是<strong>测试代码覆盖率的工具</strong>，配合gcc一起实现对c/c++文件的语句覆盖和分支覆盖。</p>
<p>Gcov能做什么？<br>每行代码执行的频次<br>实际执行了哪些代码<br>每段代码执行花耗的时间</p>
<p><img src="1.png" alt="img"></p>
<h1 id="gcov的执行过程概况"><a href="#gcov的执行过程概况" class="headerlink" title="gcov的执行过程概况"></a>gcov的执行过程概况</h1><p><img src="2.png" alt="img"><br>所谓桩点，其实就是一个变量，内存中的一个格子，对应的代码执行一次，则其值增加一次；</p>
<p>仍有2个问题：</p>
<ol>
<li>为什么是汇编文件插桩？</li>
<li>如何插桩？</li>
</ol>
<h1 id="Gcov-amp-lcov-生成报告的4个过程"><a href="#Gcov-amp-lcov-生成报告的4个过程" class="headerlink" title="Gcov &amp; lcov 生成报告的4个过程"></a>Gcov &amp; lcov 生成报告的4个过程</h1><p><img src="3.png" alt="img"><br>说明：</p>
<ol>
<li>对.c和.h文件进行编译，会生成汇编.s，可执行文件helloworld_gcov以及.gcno文件。其中编译规则中加入编译器参数-ftest-coverage是为了生成.gcno文件。加入-fprofile-arcs 是为了生成.gcda文件。</li>
<li>执行刚刚生成的可执行文件，可得到.gcda文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;helloworld_gcov</span><br></pre></td></tr></table></figure></li>
<li>通过运行命令，生成.c.gcov文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcov helloworld_gcov.c</span><br></pre></td></tr></table></figure></li>
<li>再根据.gcno和.gcda文件生成图形化报告</li>
</ol>
<p>问题：<br>.c.gcov，.gcda，.gcno文件格式？</p>
<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/22/makefile%E5%A6%82%E4%BD%95%E4%B9%A6%E5%86%99%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/makefile%E5%A6%82%E4%BD%95%E4%B9%A6%E5%86%99%EF%BC%9F/" class="post-title-link" itemprop="url">makefile如何书写？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 19:33:25" itemprop="dateCreated datePublished" datetime="2020-11-22T19:33:25+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-17 15:07:44" itemprop="dateModified" datetime="2020-11-17T15:07:44+08:00">2020-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br>  2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br>  3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/22/hello.c%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/hello.c%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">hello.c的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 19:33:25" itemprop="dateCreated datePublished" datetime="2020-11-22T19:33:25+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-16 20:53:27" itemprop="dateModified" datetime="2020-11-16T20:53:27+08:00">2020-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="编译的整个过程：预编译、编译、汇编、链接"><a href="#编译的整个过程：预编译、编译、汇编、链接" class="headerlink" title="编译的整个过程：预编译、编译、汇编、链接"></a>编译的整个过程：预编译、编译、汇编、链接</h1><p>.c–&gt;.i–&gt;.s–&gt;.o–&gt;exe</p>
<p><img src="C:\Users\fuqu.chen\AppData\Roaming\Typora\typora-user-images\image-20201116203340097.png" alt="image-20201116203340097"></p>
<p><img src="C:\Users\fuqu.chen\AppData\Roaming\Typora\typora-user-images\image-20201116204031119.png" alt="image-20201116204031119"></p>
<p><img src="C:\Users\fuqu.chen\AppData\Roaming\Typora\typora-user-images\image-20201116204145238.png" alt="image-20201116204145238"></p>
<p><img src="C:\Users\fuqu.chen\AppData\Roaming\Typora\typora-user-images\image-20201116204514439.png" alt="image-20201116204514439"></p>
<p><img src="C:\Users\fuqu.chen\AppData\Roaming\Typora\typora-user-images\image-20201116204524509.png" alt="image-20201116204524509"></p>
<p><strong>4.链接</strong></p>
<blockquote>
<p>链接器将生产的多个.o文件链接到一起生成一个可执行.exe文件；<br>但是在这个过程中，链接器做的一个重要的事情是将每个文件中call指令后面的地址补充上；方式是从当前文件的函数地址符表中开始找，如果没有，继续向别的文件的函数地址符表中找，找到后填补在call指令后面，如果找不到，则链接失败。**</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/22/android-%E5%AE%9A%E5%88%B6%E4%BA%A7%E5%93%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%83%A7%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/android-%E5%AE%9A%E5%88%B6%E4%BA%A7%E5%93%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%83%A7%E5%BD%95/" class="post-title-link" itemprop="url">android 定制产品的编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 19:33:25" itemprop="dateCreated datePublished" datetime="2020-11-22T19:33:25+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-20 19:51:30" itemprop="dateModified" datetime="2020-11-20T19:51:30+08:00">2020-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定制新产品"><a href="#定制新产品" class="headerlink" title="定制新产品"></a>定制新产品</h1><h2 id="在device目录下添加文件夹"><a href="#在device目录下添加文件夹" class="headerlink" title="在device目录下添加文件夹"></a>在device目录下添加文件夹</h2><h3 id="device-目录的组织架构"><a href="#device-目录的组织架构" class="headerlink" title="device 目录的组织架构"></a>device 目录的组织架构</h3><p>device–&gt;company–&gt;product–&gt;(vendorsetup.sh, AndroidProducts.mk, BoardConfig.mk, device.mk,…)</p>
<h3 id="定制新设备所需的配置文件分类"><a href="#定制新设备所需的配置文件分类" class="headerlink" title="定制新设备所需的配置文件分类"></a>定制新设备所需的配置文件分类</h3><p>底层往上：芯片架构–&gt;核心板–&gt;设备–&gt; 产品<br>芯片架构(architecture)：产品所需的硬件架构，eg: x86, arm<br>核心板层(board)：<br>设备层(device)：外围设备的配置<br>产品层(product)：软件模块和配置</p>
<h2 id="vendorsetup-sh"><a href="#vendorsetup-sh" class="headerlink" title="vendorsetup.sh"></a>vendorsetup.sh</h2><p>该脚本告知系统添加了目录，脚本内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_lunch_combo full_toro_userdebug</span><br><span class="line">函数add_lunch_combo作用：将参数full_toro_userdebug描述的产品添加到系统相关变量中，后面Lunch的选单就是基于这些变量产生的</span><br></pre></td></tr></table></figure>
<p>何时调用 vendorsetup.sh ？<br>vendorsetup.sh被envsetup.sh调用，在envsetup.sh脚本里有个for循环，扫描工程里所有可用的vendorsetup.sh，一般默认扫描vendor和device目录。<br>这里就有点类似超市工作人员（编译系统）扫描仓库（vendor和device目录），清点有哪些商品(vendorsetup.sh负责记录)，并通过一定方式上架(add_lunch_combo)，消费者再选购(lunch)。    </p>
<h2 id="添加AndroidProducts-mk"><a href="#添加AndroidProducts-mk" class="headerlink" title="添加AndroidProducts.mk"></a>添加AndroidProducts.mk</h2><p>通过AndroidProducts.mk指向其他.mk文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_MAKEFILES :&#x3D; \</span><br><span class="line">	$(LOCAL_PATH)&#x2F;aosp_toro.mk \</span><br><span class="line">	$(LOCAL_PATH)&#x2F;full_toro.mk</span><br></pre></td></tr></table></figure>
<p>其中aosp_toro.mk和full_toro.mk是某产品专用makefile文件。</p>
<h2 id="实现上述某产品专用的makefile文件"><a href="#实现上述某产品专用的makefile文件" class="headerlink" title="实现上述某产品专用的makefile文件"></a>实现上述某产品专用的makefile文件</h2><p>利用<strong>系统已有</strong>的**<em>全局**</em>变量和函数实现需要的功能</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PRODUCT_NAME</td>
<td>产品名称</td>
</tr>
<tr>
<td>2</td>
<td>PRODUCT_DEVICE</td>
<td>设备名称</td>
</tr>
<tr>
<td>3</td>
<td>PRODUCT_BRAND</td>
<td>产品所属品牌</td>
</tr>
<tr>
<td>4</td>
<td>PRODUCT_MANUFACTURER</td>
<td>产品生产商</td>
</tr>
<tr>
<td>5</td>
<td>PRODUCT_MODEL</td>
<td>产品型号</td>
</tr>
<tr>
<td>6</td>
<td>PRODUCT_PACKAGES</td>
<td>系统需预装的一系列程序</td>
</tr>
<tr>
<td>7</td>
<td>PRODUCT_LOCALES</td>
<td>所支持的国家语言</td>
</tr>
<tr>
<td>8</td>
<td>PRODUCT_POLICY</td>
<td>本产品遵循的策略。例：android.policy_phone</td>
</tr>
<tr>
<td>9</td>
<td>PRODUCT_TAGS</td>
<td>产品 标签描述，以空格分隔</td>
</tr>
<tr>
<td></td>
<td>PRODUCT_PROPERTY_OVERRIDES</td>
<td>用于重载系统属性，存储在/system/build/.prop文件中。格式：key=value，例：ro.product.firmware=v0.4rc1</td>
</tr>
</tbody></table>
<h2 id="添加BoardConfig-mk文件"><a href="#添加BoardConfig-mk文件" class="headerlink" title="添加BoardConfig.mk文件"></a>添加BoardConfig.mk文件</h2><ol>
<li>目标架构</li>
<li>硬件设备属性</li>
<li>编译器的条件标志</li>
<li>分区布局</li>
<li>Boot地址</li>
<li>ramdisk大小</li>
</ol>
<h2 id="添加Android-mk"><a href="#添加Android-mk" class="headerlink" title="添加Android.mk"></a>添加Android.mk</h2><p>产品由很多模块组成，Android.mk是生产某个模块的“生产工序”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/22/android-%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/android-%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">原生态android 编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 19:33:25" itemprop="dateCreated datePublished" datetime="2020-11-22T19:33:25+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-19 11:12:11" itemprop="dateModified" datetime="2020-11-19T11:12:11+08:00">2020-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于交叉编译"><a href="#关于交叉编译" class="headerlink" title="关于交叉编译"></a>关于交叉编译</h1><h2 id="什么是交叉编译？"><a href="#什么是交叉编译？" class="headerlink" title="什么是交叉编译？"></a>什么是交叉编译？</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>（1）目标平台由于种种原因（无法安装编译器，资源有限导致编译不正常）<br>（2）需要另外一个平台辅助生成可执行文件</p>
<p>平台是指？<br>平台=硬件+ 操作系统环境</p>
<h3 id="引出相关概念："><a href="#引出相关概念：" class="headerlink" title="引出相关概念："></a>引出相关概念：</h3><p>宿主机（host）：开发和编译代码所在平台<br>目标机（target）：宿主机编译生成的系统包就是提供给目标机使用的<br>交叉编译器（cross compiler）：本身在宿主机上运行，用于产生目标机可执行文件的编译器</p>
<h3 id="常用交叉编译器及应用环境"><a href="#常用交叉编译器及应用环境" class="headerlink" title="常用交叉编译器及应用环境"></a>常用交叉编译器及应用环境</h3><ol>
<li>在Windows PC上，利用ADS ARM开发环境，使用armcc编译器，可编译出针对ARMCPU的可执行代码。</li>
<li>在Linux PC上，利用arm-linux-gcc编译器，可编译出针对Linux ARM平台的可执行代码。</li>
<li>在Windows PC上，利用cygwin环境，运行arm-elf-gcc编译器，可编译出针对ARM CPU的可执行代码。</li>
<li>在Windows系统上，利用Keil Uvison工具，开发出运行在89C51单片机上的程序。</li>
<li>在Windows系统上，利用CodeWarrior IDE工具，开发出运行在Freescale XS128单片机上的程序。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>编译的环境和运行的环境是不一样，是属于交叉的，此所谓cross；</li>
</ol>
<h1 id="建立android编译环境"><a href="#建立android编译环境" class="headerlink" title="建立android编译环境"></a>建立android编译环境</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>宿主机：linux x86 pc<br>宿主机操作系统：ubuntu 14.04 LTS<br>交叉编译器：arm-linux-gcc<br>通用编译工具：<br>（1）python2.x<br>（2）GNU make 3.81-3.82<br>（3）JDK<br>（4）git 1.7以上版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装版本下载地址及相应安装命令如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><h3 id="step1-执行envsetup-sh"><a href="#step1-执行envsetup-sh" class="headerlink" title="step1: 执行envsetup.sh"></a>step1: 执行envsetup.sh</h3><p>envsetup.sh记录编译过程中所需的各种函数实现，如lunch ,mm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source .&#x2F;build&#x2F;envsetup.sh</span><br><span class="line">等价于</span><br><span class="line">. .&#x2F;build&#x2F;envsetup.sh</span><br></pre></td></tr></table></figure>
<h3 id="step2-选择编译目标"><a href="#step2-选择编译目标" class="headerlink" title="step2: 选择编译目标"></a>step2: 选择编译目标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<p>输入lunch后会弹出工程配置好的所有产品类型，我们再进行产品类型的选择</p>
<h3 id="step3：执行编译命令"><a href="#step3：执行编译命令" class="headerlink" title="step3：执行编译命令"></a>step3：执行编译命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>也可以充分利用cpu资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何编译出SDK？"><a href="#如何编译出SDK？" class="headerlink" title="如何编译出SDK？"></a>如何编译出SDK？</h3><h4 id="mac-os和linux下"><a href="#mac-os和linux下" class="headerlink" title="mac os和linux下"></a>mac os和linux下</h4><ol>
<li>下载源码</li>
<li>source ./build/envsetup.sh</li>
<li>lunch sdk-eng</li>
<li>make sdk</li>
</ol>
<h4 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h4><ol>
<li>在linux下生成sdk</li>
<li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mingw32 tofrodos</span><br></pre></td></tr></table></figure></li>
<li> 再次编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source .&#x2F;build&#x2F;envsetup.sh</span><br><span class="line">lunch sdk-eng</span><br><span class="line">make win_sdk</span><br></pre></td></tr></table></figure>













</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/22/linux-synchronize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/linux-synchronize/" class="post-title-link" itemprop="url">内核同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-22 19:33:25 / 修改时间：22:55:19" itemprop="dateCreated datePublished" datetime="2020-11-22T19:33:25+08:00">2020-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="临界区，临界资源，并发，竞争条件，同步"><a href="#临界区，临界资源，并发，竞争条件，同步" class="headerlink" title="临界区，临界资源，并发，竞争条件，同步"></a>临界区，临界资源，并发，竞争条件，同步</h1><p><strong>临界区</strong>就是访问和操作共享数据的代码段。<br>属于<strong>临界资源</strong>的硬件有打印机、磁带机等,软件有消息缓冲队列、变量、数组、缓冲区等。</p>
<p>示意图如下：</p>
<p><img src="1.png" alt="img"></p>
<p>如上图，代码段code1,code2,code3分别都访问和操作同一块数据区域，因此这些代码段就是临界区，而这块数据区域就是临界资源。实际上，code离不开data，笔者认为临界区也包括了指令操作的数据，正如上图红色，黄色，绿色所圈。</p>
<p>试想，倘若操作的先后顺便不一致，共享数据最终的呈现状态会不会不一样呢？<br><strong>并发</strong>指多个执行单元<strong>同时</strong>访问同一个资源。<br><strong>竞争条件</strong>指多个线程或者进程在读写一个共享数据时结果依赖于它们<strong>执行的相对时间</strong>的情形。</p>
<p><strong>同步</strong>就是避免并发和防止竞争条件。</p>
<p><img src="2.png" alt="img"></p>
<p>假设线程1执行指令i++，线程2执行指令++i。每一行代表一个时间片。上面表示线程1执行完后才执行线程2.  下面表示，线程1和线程2同时获得变量i，此时i的值为8，下一个时间片，线程1进行i++操作，而线程2在此时未处理（sleep），接下来的一个时间片，线程1sleep，而线程2进行++i操作。接下来的又一个时间片，线程1得到i的值为9，线程2得到的i的值也为9. </p>
<p>#死锁<br><strong>死锁</strong>就是线程等待的资源不释放，线程无法继续。<br><strong>自死锁</strong>：线程试图获得自己已持有的锁。<br><strong>ABBA死锁</strong>：如下图，每行表示一个时间片，线程1和线程2同时分别获得锁A和锁B，在下一个时间片，线程1试图获取锁B（已被线程2持有，需要等待线程2释放锁B），线程2试图获取锁A（已被线程1持有，需要等待线程1释放锁A）。然而，线程2想要释放锁B，就必须先完成获得锁A这件事，它在等待线程1释放锁A。线程1想要释放锁A，就必须先完成获得锁B这件事，它在等待线程2释放锁B。于是，线程1和线程2由于相互想要获得对方的锁，进入死锁状态，这就是ABBA死锁。<br><img src="3.png" alt="img"></p>
<p><strong>如何规避死锁</strong></p>
<ol>
<li>按加锁相反的顺序解锁：加锁（a-&gt;b-&gt;c），解锁（c-&gt;b-&gt;a）</li>
<li>防止饥饿：设置超时时间，防止永远等待</li>
<li>不要重复请求 同一个锁</li>
<li>加锁方案要设计得简单</li>
</ol>
<p>#锁的争用<br>锁lock：使程序以串行方式对资源进行访问<br>lock contention：锁被占用时，其他线程等待获得该锁</p>
<p>锁的扩展性：<br>锁的粒度：粗锁保护大块数据，细锁保护小块数据<br>运行队列锁被争用：本质是在调度程序中把整个调度进程下放到单个处理器执行</p>
<h1 id="原子"><a href="#原子" class="headerlink" title="原子"></a>原子</h1><p><strong>原子操作</strong>：指令执行过程不被打断<br>原子操作只能用于临界区只有一个变量的情况。</p>
<p>为什么可以不被打断？</p>
<h2 id="原子整数操作"><a href="#原子整数操作" class="headerlink" title="原子整数操作"></a>原子整数操作</h2><h3 id="32位原子整数操作"><a href="#32位原子整数操作" class="headerlink" title="32位原子整数操作"></a>32位原子整数操作</h3><p>原子整数操作：只对atomic类型数据进行处理<br><img src="4.png" alt="img"></p>
<p>函数及相应的描述：<br><img src="5.png" alt="img"></p>
<h3 id="64位原子整数操作"><a href="#64位原子整数操作" class="headerlink" title="64位原子整数操作"></a>64位原子整数操作</h3><h2 id="原子位操作"><a href="#原子位操作" class="headerlink" title="原子位操作"></a>原子位操作</h2><p><img src="5-1.png" alt="img"></p>
<p><img src="5-2.png" alt="img"></p>
<p><img src="5-3.png" alt="img"></p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁同一时刻只能被一个执行线程持有，其余想持有的必须等待，cpu一直忙等待，未睡眠,所以会造成CPU处理时间的浪费。自旋就是等待自己释放锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义自旋锁</span><br><span class="line">初始化自旋锁</span><br><span class="line">获取自旋锁，保护临界区</span><br><span class="line">&#x2F;*临界区code &amp; data *&#x2F;</span><br><span class="line">解锁</span><br></pre></td></tr></table></figure>
<p>自旋锁使用时有2点需要注意：<br>1：自旋锁是<strong>不可递归</strong>的，递归的请求同一个自旋锁会自己锁死自己。</p>
<p>2：线程获取自旋锁之前，要禁止当前处理器上的中断。（防止获取锁的线程和中断形成竞争条件）<br>比如：当前线程获取自旋锁后，在临界区中被中断处理程序打断，中断处理程序正好也要获取这个锁，于是中断处理程序会等待当前线程释放锁，而当前线程也在等待中断执行完后再执行临界区和释放锁的代码。</p>
<p>笔者认为这里就是ABBA锁，只不过这里线程2恰巧就是中断而已。</p>
<p><img src="6.png" alt="img"></p>
<h1 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h1><p>允许读的并发，即可多个读进程，但只允许1个写进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义和初始化读写自旋锁</span><br><span class="line">读锁定</span><br><span class="line">读解锁</span><br><span class="line">写锁定</span><br><span class="line">写解锁</span><br></pre></td></tr></table></figure>



<h1 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h1><p>被顺序锁保护的共享资源，读和写不互斥。读期间发生了写，则需要重新读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">写顺序锁</span><br><span class="line">&#x2F;*写代码*&#x2F;</span><br><span class="line">释放写顺序锁</span><br></pre></td></tr></table></figure>



<h1 id="读-复制-更新"><a href="#读-复制-更新" class="headerlink" title="读-复制-更新"></a>读-复制-更新</h1><p>RCU：read-copy-update</p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量，又名semaphore，是一种  用于同步和互斥的手段。<br>特点：睡眠锁，等待的过程不会占用CPU时间，适用于等待时间较长的临界区。<br>信号量消耗的CPU时间的地方在于使线程睡眠和唤醒线程，如果(使线程睡眠 + 唤醒线程)的CPU时间 &gt; 线程自旋等待的CPU时间，那么可以考虑使用自旋锁。<br>信号量的值可以是0，1，n。总之非负整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义信号量</span><br><span class="line">初始化信号量</span><br><span class="line">获得信号量</span><br><span class="line">释放信号量</span><br></pre></td></tr></table></figure>
<p>信号量用于互斥和同步<br>互斥：<br>同步：</p>
<p><img src="7.png" alt="img"></p>
<h1 id="PV原语"><a href="#PV原语" class="headerlink" title="PV原语"></a>PV原语</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P(S)等价于S&#x3D;S-1</span><br><span class="line">if (S&gt;&#x3D;0)</span><br><span class="line">	进程继续；</span><br><span class="line">else</span><br><span class="line">	进程进入等待队列；</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V(S)等价于S&#x3D;S+1</span><br><span class="line">if(S&gt;0)</span><br><span class="line">	该进程被唤醒，返回调用处继续执行</span><br><span class="line">else</span><br><span class="line">	从等待队列中唤醒一等待进程</span><br></pre></td></tr></table></figure>
<p>S=0<br>P(S)则S=-1，进程等待<br>V(S)则S=0，进程等待</p>
<h1 id="信号量与自旋锁的区别"><a href="#信号量与自旋锁的区别" class="headerlink" title="信号量与自旋锁的区别"></a>信号量与自旋锁的区别</h1><p>信号量表面看和自旋锁很相似，区别在于争用自旋锁的线程会一直循环尝试获取自旋锁，而争用信号量的线程在信号量为0时，会进入睡眠，信号量可用时再被唤醒。</p>
<h1 id="计数信号量和二值信号量"><a href="#计数信号量和二值信号量" class="headerlink" title="计数信号量和二值信号量"></a>计数信号量和二值信号量</h1><p>信号量有二值信号量和计数信号量2种，其中二值信号量比较常用。</p>
<p>二值信号量：<br>表示信号量只有2个值，即0和1。信号量为1时，表示临界区可用，信号量为0时，表示临界区不可访问。<br> <br>计数信号量：初始化时把数量设为大于1的非0值<br>计数信号量有个计数值，比如计数值为5，表示同时可以有5个线程访问临界区。</p>
<h1 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h1><p>互斥体也是一种可以睡眠的锁，相当于二值信号量，只是提供的API更加简单，使用的场景也更严格一些，如下所示：<br>1：mutex的计数值只能为1，也就是最多只允许一个线程访问临界区<br>2：在同一个上下文中上锁和解锁，给mutex上锁者必须负责给其解锁<br>3：递归地上锁和解锁是不允许的。也就是说，你不能递归地持有同一个锁，同样你也不能再去解锁一个已经被       解开的mutex.<br>4：持有1个mutex时，进程不能退出<br>5：mutex不能在中断或者下半部中使用，也就是mutex只能在进程上下文中使用<br>6：mutex只能通过官方API来管理，不能自己写代码操作它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义互斥体</span><br><span class="line">初始化互斥体</span><br><span class="line">获取互斥体</span><br><span class="line">释放互斥体</span><br></pre></td></tr></table></figure>
<p><img src="8.png" alt="img"><br>互斥体的实现依赖于自旋体，互斥体是进程级的，用于多个进程之间对资源的互斥。</p>
<h1 id="各种锁使用的场景pk"><a href="#各种锁使用的场景pk" class="headerlink" title="各种锁使用的场景pk"></a>各种锁使用的场景pk</h1><h1 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/newnewman80/article/details/16112669">https://blog.csdn.net/newnewman80/article/details/16112669</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tureno/articles/6080923.html">https://www.cnblogs.com/tureno/articles/6080923.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaostudy/p/6670693.html">https://www.cnblogs.com/linhaostudy/p/6670693.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edver/p/7260696.html">https://www.cnblogs.com/edver/p/7260696.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38619183/article/details/83097475">https://blog.csdn.net/qq_38619183/article/details/83097475</a></p>
<h1 id="实现设备只能被一个进程打开的3种方式"><a href="#实现设备只能被一个进程打开的3种方式" class="headerlink" title="实现设备只能被一个进程打开的3种方式"></a>实现设备只能被一个进程打开的3种方式</h1><h2 id="原子变量实现设备只能被一个进程打开"><a href="#原子变量实现设备只能被一个进程打开" class="headerlink" title="原子变量实现设备只能被一个进程打开"></a>原子变量实现设备只能被一个进程打开</h2><p>过程描述：</p>
<ol>
<li>假设线程A拿到了原子变量xxx_available，执行函数atomic_dec_and_test(&amp;xxx_available)，变量xxx_available由1减1变成了0，此时函数返回True。接着取反为FALSE，不走if{}内的内容了。执行后面打开设备的代码。</li>
<li>假设现在又线程B想要打开设备，首先它来取原子变量xxx_available，此时变量值为0，执行行函数atomic_dec_and_test(&amp;xxx_available)，变量xxx_available由0减1变成-1，此时函数返回flase，取反为true，走if{}的内容。执行函数atomic_inc(&amp;xxx_available)，于是变量xxx_available由-1加1，变成0，返回-EBUSY。</li>
<li>接着又一个线程C想打开设备，只要线程A未释放原子变量，其他线程都要经历步骤2.</li>
<li>假设线程A此刻释放原子变量，即执行atmomic_inc(&amp;xxx_available);那么，变量恢复值1.其他线程想要打开设备，将执行步骤1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static atomic_t xxx_available &#x3D; ATOMIC_INIT(1); &#x2F;&#x2F;定义原子变量xxx_available，并赋初值1给它。</span><br><span class="line">static int xxx_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">if(!atomic_dec_and_test(&amp;xxx_available))&#123;</span><br><span class="line">    atomic_inc(&amp;xxx_available);</span><br><span class="line">    return -EBUSY; </span><br><span class="line"> &#125;</span><br><span class="line">...&#x2F;*这里才是打开的代码段*&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int xxx_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    atmomic_inc(&amp;xxx_available);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fd &#x3D; xxx_open (&quot;&#x2F;dev&#x2F;buttons&quot;, O_RDWR);</span><br><span class="line">if (fd &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;can&#39;t open!\n&quot;);</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="自旋锁实现设备只能被一个进程打开"><a href="#自旋锁实现设备只能被一个进程打开" class="headerlink" title="自旋锁实现设备只能被一个进程打开"></a>自旋锁实现设备只能被一个进程打开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int xxx_count &#x3D; 0;&#x2F;&#x2F; 定义文件打开次计数</span><br><span class="line">static int xxx_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">   spinlock(&amp;xxx_lock);</span><br><span class="line">    if(xxx_count)&#123; &#x2F;&#x2F;已经打开</span><br><span class="line">        spin_unlock(&amp;xxx_lock);</span><br><span class="line">        return -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line">    xxx_count++;&#x2F;&#x2F;增加计数</span><br><span class="line">    spin_unlock(&amp;xxx_lock);</span><br><span class="line">    ...</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int xxx_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    spinlock(&amp;xxx_lock);</span><br><span class="line">    xxx_count--;</span><br><span class="line">    spin_unlock(&amp;xxx_lock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="信号量实现设备只能被一个进程打开"><a href="#信号量实现设备只能被一个进程打开" class="headerlink" title="信号量实现设备只能被一个进程打开"></a>信号量实现设备只能被一个进程打开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static DECLARE_MUTEX(xxx_lock);</span><br><span class="line">&#x2F;*strcut semaphore sem</span><br><span class="line"> * init_MUTEX(&amp;sem);</span><br><span class="line"> * 2.6.25版本后不适用init_MUTEX,用sema_init(sem,1)代替 </span><br><span class="line">*&#x2F;</span><br><span class="line">static int xxx_open(struct inode *inode, struct file *filep)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if(down_trylock(&amp;xxx_lock))  &#x2F;&#x2F;第一次打开获取锁，第二次打开不能获取</span><br><span class="line">    return -EBUSY;</span><br><span class="line">...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int xxx_release(struct inode,struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    up(&amp;xxx_lock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/15/Qt2-signal-slot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/Qt2-signal-slot/" class="post-title-link" itemprop="url">Qt中信号与槽--窗体可视化设计篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-15 12:20:20 / 修改时间：13:49:15" itemprop="dateCreated datePublished" datetime="2020-11-15T12:20:20+08:00">2020-11-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-打开Qt-Creator，新建工程"><a href="#1-打开Qt-Creator，新建工程" class="headerlink" title="1.打开Qt Creator，新建工程"></a>1.打开Qt Creator，新建工程</h3><p><img src="1.PNG" alt="img"></p>
<p>###2.工程选择application-&gt;Qt Widgets Application</p>
<p><img src="2.PNG" alt="img"></p>
<p>###3.工程命名为QtApp，保存在路径文件夹Demo2_3中</p>
<p><img src="3.PNG" alt="img"></p>
<p>###4.编译工具勾选mingw 64 bit</p>
<p><img src="4.PNG" alt="img"></p>
<p>###5.选择基类对话框QDialog，将创建Dialog.h和Dialog.cpp。勾选Generate from，将创建Dialog.ui。</p>
<p><img src="5.png" alt="img"></p>
<p>###6.版本控制可不做选择，这里添加了git来做版本控制。按finish结束项目新建。</p>
<p><img src="6.png" alt="img"></p>
<p>###7.QtApp.pro是项目文件，Qt Creator打开QtApp.pro即打开这个项目。Dialog.ui是窗体UI文件，双击则进入Design 进行可视化设计。</p>
<p><img src="7.png" alt="img"></p>
<p>###8.下面进行UI设计，先双击.ui文件，打开窗口</p>
<p><img src="8.png" alt="img"></p>
<p>###9.先拖入容器Group Box，在该容器内再拖入3个checkBox。现在假如拖动Group Box，则3个checkbox也会跟着动。</p>
<p><img src="9.png" alt="img"></p>
<p>###10.拖入垂直布局vertical Layout，再往其中拖入3个radio button，在两两radio button之间插入一个horizontal Spacer。于是，这个3个radio button以水平等距离布局呈现。下面3个pushbutton按钮以此方式进行。</p>
<p><img src="10.png" alt="img"></p>
<p>###11.下面对各个组件进行设置：选中中间那个pushbutton按钮，修改其objectName为btnOK, text内容为“确定”。</p>
<p><img src="10-1.png" alt="img"></p>
<p>拖入plainTextEdit组件，写好text内容，修改字体大小为20.</p>
<p><img src="10-2.png" alt="img"></p>
<p>最终所以组件呈现方式：</p>
<p><img src="11.png" alt="img"></p>
<p>###12.下面进行“信号与槽”的设计，edit-&gt;edit signals/slots，进入编辑状态。</p>
<p><img src="12.png" alt="img"></p>
<p>###13.选中“确定”按钮不放，拖向空白区，会弹出连接配置。这里选择clicked()信号，accept()槽函数。</p>
<p><img src="13.png" alt="img"></p>
<p>###14.我们可以勾选“show signals and slots inherited from QWidget”来看隐藏的选项。</p>
<p><img src="14.png" alt="img"></p>
<p>在下方的singal slots edit界面可以看到刚刚为btnOK和btnClose添加的信号和槽函数。</p>
<p><img src="15.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/10/Qt3-signal-slot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/Qt3-signal-slot/" class="post-title-link" itemprop="url">Qt 中信号与槽--第二篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-10 22:27:25" itemprop="dateCreated datePublished" datetime="2020-11-10T22:27:25+08:00">2020-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-15 14:03:36" itemprop="dateModified" datetime="2020-11-15T14:03:36+08:00">2020-11-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#项目程序架构<br>##项目文件组成<br>##批处理文件<br>##窗体界面定义文件<br>##窗体业务逻辑类文件<br>##应用程序主程序文件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Queenie Chen</p>
  <div class="site-description" itemprop="description">我叫小白，初来乍到，请多指教~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Queenie Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
