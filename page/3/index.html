<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"queeniechen.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我叫小白，初来乍到，请多指教~">
<meta property="og:type" content="website">
<meta property="og:title" content="Queenie Chen">
<meta property="og:url" content="https://queeniechen.github.io/page/3/index.html">
<meta property="og:site_name" content="Queenie Chen">
<meta property="og:description" content="我叫小白，初来乍到，请多指教~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Queenie Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://queeniechen.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Queenie Chen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Queenie Chen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">三十功名尘与土，八千里路云和月</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/7-c++_struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/7-c++_struct/" class="post-title-link" itemprop="url">c++入门--struct</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-13 21:08:48 / 修改时间：21:26:05" itemprop="dateCreated datePublished" datetime="2020-12-13T21:08:48+08:00">2020-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>date:2020.11.23</p>
<p>结构体：<br>下面声明了一个结构体Books，变量为book：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">	char title[50];</span><br><span class="line">	char author[50];</span><br><span class="line">	char subject[100];</span><br><span class="line">	int book_id;</span><br><span class="line">&#125;book;&#x2F;&#x2F;这里有分号</span><br></pre></td></tr></table></figure>
<p>如何访问结构体成员？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Books book1;&#x2F;&#x2F;定义结构体类型Books的变量book1</span><br><span class="line"></span><br><span class="line">book1.book_id &#x3D; 12;</span><br></pre></td></tr></table></figure>

<p>结构体作为函数参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void printBook(struct Books book)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;书标题&quot;&lt;&lt;book.title&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指向结构的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义</span><br><span class="line">struct Books *struct_pointer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在指针变量struct_pointer中存储结构变量book1的地址</span><br><span class="line">struct_pointer &#x3D; &amp;book1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用指针访问结构的成员</span><br><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<p>取别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Books</span><br><span class="line">&#123;</span><br><span class="line">char title[50];</span><br><span class="line">char author[50];</span><br><span class="line">int book_id;</span><br><span class="line">&#125;Books;</span><br><span class="line"></span><br><span class="line">Books cfq_book,cqq_book;&#x2F;&#x2F;使用Books定义</span><br><span class="line"></span><br><span class="line">typedef long int *pointer_int32;</span><br><span class="line"></span><br><span class="line">pointer_int32 a,b,c;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/6-c++_class-member-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/6-c++_class-member-function/" class="post-title-link" itemprop="url">c++入门--类成员函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-13 21:08:48 / 修改时间：21:26:00" itemprop="dateCreated datePublished" datetime="2020-12-13T21:08:48+08:00">2020-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>date:2020.11.23</p>
<p>what is class member function?<br>定义和原型都写在类定义内部的函数，成为类成员函数。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。</p>
<p>there are 2 methods to define a class member function:<br>the first method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。所以您可以按照如下方式定义 Volume() 函数：</span><br><span class="line">*&#x2F;</span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;      &#x2F;&#x2F; 长度</span><br><span class="line">      double breadth;     &#x2F;&#x2F; 宽度</span><br><span class="line">      double height;      &#x2F;&#x2F; 高度</span><br><span class="line">   </span><br><span class="line">      double getVolume(void)</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>the second method:<br>范围解析运算符 ::</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double Box::getVolume(void)</span><br><span class="line">&#123;</span><br><span class="line">    return length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用成员函数是在对象上使用点运算符（.），这样它就能操作与该对象相关的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box myBox;          &#x2F;&#x2F; 创建一个对象</span><br><span class="line"> </span><br><span class="line">myBox.getVolume();  &#x2F;&#x2F; 调用该对象的成员函数</span><br></pre></td></tr></table></figure>














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/5-c++_class_object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/5-c++_class_object/" class="post-title-link" itemprop="url">c++入门--类&对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-13 21:08:48 / 修改时间：21:25:55" itemprop="dateCreated datePublished" datetime="2020-12-13T21:08:48+08:00">2020-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>date:2020.11.23</p>
<p>类：用户定义的类型，指定数据表示法和处理数据的方法，data和method也被称为类的成员。</p>
<p>how to define a class？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box&#x2F;&#x2F;关键字class，后面的Box是类名</span><br><span class="line">&#123;</span><br><span class="line">	public:&#x2F;&#x2F;关键字public指定了类成员的访问属性，公共成员在类的外部是可访问的</span><br><span class="line">		double length;</span><br><span class="line">		double breadth;</span><br><span class="line">		double height;</span><br><span class="line">&#125;;&#x2F;&#x2F;这里的分号不要忘了</span><br></pre></td></tr></table></figure>

<p>how to define a object?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box box1;&#x2F;&#x2F;声明box1,类型为Box</span><br></pre></td></tr></table></figure>

<p>如何访问公有数据成员？私有数据成员？受保护的成员？</p>
<p>结构体和类的区别？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/4-c++_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/4-c++_1/" class="post-title-link" itemprop="url">c++入门--类访问修饰符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-13 21:08:48 / 修改时间：21:25:49" itemprop="dateCreated datePublished" datetime="2020-12-13T21:08:48+08:00">2020-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>date:2020.11.23</p>
<p>关键字 public、private、protected 称为访问修饰符。<br>成员和类的默认访问修饰符是 private。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line"> </span><br><span class="line">   public:</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 公有成员</span><br><span class="line"> </span><br><span class="line">   protected:</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 受保护成员</span><br><span class="line"> </span><br><span class="line">   private:</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 私有成员</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>public<br>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Line</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		double length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">	Line line;</span><br><span class="line">	line.length &#x3D; 10.0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>private<br>默认情况下，类的所有成员都是私有的。私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   double width;</span><br><span class="line">   public:</span><br><span class="line">      double length;</span><br><span class="line">      void setWidth( double wid );</span><br><span class="line">      double getWidth( void );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/3-assembly-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/3-assembly-language/" class="post-title-link" itemprop="url">assembly language</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-13 21:08:48" itemprop="dateCreated datePublished" datetime="2020-12-13T21:08:48+08:00">2020-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-25 14:17:54" itemprop="dateModified" datetime="2020-11-25T14:17:54+08:00">2020-11-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>data:2020-11-24</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。计算机真正能够理解的是低级语言，它专门用来控制硬件。<br><img src="1.png" alt="image"></p>
<p>编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码（二进制，比如加法指令就是00000011）。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就<strong>诞生了汇编语言</strong>。</p>
<p>汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>
<h1 id="汇编是什么"><a href="#汇编是什么" class="headerlink" title="汇编是什么"></a>汇编是什么</h1><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>
<p>assembling：文字指令翻译成二进制<br>完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。</p>
<p>因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，<strong>那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</strong></p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。</p>
<p><img src="2.png" alt="image"></p>
<p>32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p>
<p>EAX<br>EBX<br>ECX<br>EDX<br>EDI<br>ESI<br>EBP<br>ESP</p>
<p>上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p><img src="3.png" alt="image"></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="4.png" alt="image"></p>
<p>这种因为<strong>用户主动请求而划分出来的内存区域，叫做 Heap（堆）</strong>。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是<strong>不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</strong></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int a &#x3D; 2;</span><br><span class="line">	int b &#x3D; 3;</span><br><span class="line">	return add_a_and_b(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>
<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>
<p><img src="5.png" alt="image"></p>
<p>main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p><img src="6.png" alt="image"></p>
<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>
<h1 id="看c语言如何转换成汇编"><a href="#看c语言如何转换成汇编" class="headerlink" title="看c语言如何转换成汇编"></a>看c语言如何转换成汇编</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;example.c</span><br><span class="line">int add_a_and_b(int a, int b) &#123;</span><br><span class="line">   return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   return add_a_and_b(2, 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;gcc 将这个程序转成汇编语言</span><br><span class="line">gcc -S example.c</span><br></pre></td></tr></table></figure>
<p>上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;example.s</span><br><span class="line">_add_a_and_b:</span><br><span class="line">   push   %ebx</span><br><span class="line">   mov    %eax, [%esp+8] </span><br><span class="line">   mov    %ebx, [%esp+12]</span><br><span class="line">   add    %eax, %ebx </span><br><span class="line">   pop    %ebx </span><br><span class="line">   ret  </span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">   push   3</span><br><span class="line">   push   2</span><br><span class="line">   call   _add_a_and_b </span><br><span class="line">   add    %esp, 8</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
<p>可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。</p>
<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   %ebx</span><br></pre></td></tr></table></figure>


<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   3</span><br></pre></td></tr></table></figure>
<p>根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。</p>
<p>push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。如何实现？<br>push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   2</span><br></pre></td></tr></table></figure>
<p>push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。<br><img src="7.png" alt="image"></p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call _add_a_and_b</span><br></pre></td></tr></table></figure>
<p>上面的代码表示调用add_a_and_b函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push   %ebx</span><br></pre></td></tr></table></figure>
<p>这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>
<h2 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h2><p>mov指令用于将一个值写入某个寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    %eax, [%esp+8] </span><br></pre></td></tr></table></figure>
<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    %ebx, [%esp+12] </span><br></pre></td></tr></table></figure>
<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。</p>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>add指令用于将两个运算子相加，并将结果写入第一个运算子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add    %eax, %ebx</span><br></pre></td></tr></table></figure>
<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop    %ebx</span><br></pre></td></tr></table></figure>
<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>
<h2 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h2><p>ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。该指令没有运算子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add    %esp, 8 </span><br></pre></td></tr></table></figure>
<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>最后，main函数运行结束，ret指令退出程序执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/2-android-%E5%AE%9A%E5%88%B6%E4%BA%A7%E5%93%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%83%A7%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/2-android-%E5%AE%9A%E5%88%B6%E4%BA%A7%E5%93%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E7%83%A7%E5%BD%95/" class="post-title-link" itemprop="url">android 定制产品的编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-13 21:08:48" itemprop="dateCreated datePublished" datetime="2020-12-13T21:08:48+08:00">2020-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-20 19:51:30" itemprop="dateModified" datetime="2020-11-20T19:51:30+08:00">2020-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定制新产品"><a href="#定制新产品" class="headerlink" title="定制新产品"></a>定制新产品</h1><h2 id="在device目录下添加文件夹"><a href="#在device目录下添加文件夹" class="headerlink" title="在device目录下添加文件夹"></a>在device目录下添加文件夹</h2><h3 id="device-目录的组织架构"><a href="#device-目录的组织架构" class="headerlink" title="device 目录的组织架构"></a>device 目录的组织架构</h3><p>device–&gt;company–&gt;product–&gt;(vendorsetup.sh, AndroidProducts.mk, BoardConfig.mk, device.mk,…)</p>
<h3 id="定制新设备所需的配置文件分类"><a href="#定制新设备所需的配置文件分类" class="headerlink" title="定制新设备所需的配置文件分类"></a>定制新设备所需的配置文件分类</h3><p>底层往上：芯片架构–&gt;核心板–&gt;设备–&gt; 产品<br>芯片架构(architecture)：产品所需的硬件架构，eg: x86, arm<br>核心板层(board)：<br>设备层(device)：外围设备的配置<br>产品层(product)：软件模块和配置</p>
<h2 id="vendorsetup-sh"><a href="#vendorsetup-sh" class="headerlink" title="vendorsetup.sh"></a>vendorsetup.sh</h2><p>该脚本告知系统添加了目录，脚本内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_lunch_combo full_toro_userdebug</span><br><span class="line">函数add_lunch_combo作用：将参数full_toro_userdebug描述的产品添加到系统相关变量中，后面Lunch的选单就是基于这些变量产生的</span><br></pre></td></tr></table></figure>
<p>何时调用 vendorsetup.sh ？<br>vendorsetup.sh被envsetup.sh调用，在envsetup.sh脚本里有个for循环，扫描工程里所有可用的vendorsetup.sh，一般默认扫描vendor和device目录。<br>这里就有点类似超市工作人员（编译系统）扫描仓库（vendor和device目录），清点有哪些商品(vendorsetup.sh负责记录)，并通过一定方式上架(add_lunch_combo)，消费者再选购(lunch)。    </p>
<h2 id="添加AndroidProducts-mk"><a href="#添加AndroidProducts-mk" class="headerlink" title="添加AndroidProducts.mk"></a>添加AndroidProducts.mk</h2><p>通过AndroidProducts.mk指向其他.mk文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_MAKEFILES :&#x3D; \</span><br><span class="line">	$(LOCAL_PATH)&#x2F;aosp_toro.mk \</span><br><span class="line">	$(LOCAL_PATH)&#x2F;full_toro.mk</span><br></pre></td></tr></table></figure>
<p>其中aosp_toro.mk和full_toro.mk是某产品专用makefile文件。</p>
<h2 id="实现上述某产品专用的makefile文件"><a href="#实现上述某产品专用的makefile文件" class="headerlink" title="实现上述某产品专用的makefile文件"></a>实现上述某产品专用的makefile文件</h2><p>利用<strong>系统已有</strong>的**<em>全局**</em>变量和函数实现需要的功能</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PRODUCT_NAME</td>
<td>产品名称</td>
</tr>
<tr>
<td>2</td>
<td>PRODUCT_DEVICE</td>
<td>设备名称</td>
</tr>
<tr>
<td>3</td>
<td>PRODUCT_BRAND</td>
<td>产品所属品牌</td>
</tr>
<tr>
<td>4</td>
<td>PRODUCT_MANUFACTURER</td>
<td>产品生产商</td>
</tr>
<tr>
<td>5</td>
<td>PRODUCT_MODEL</td>
<td>产品型号</td>
</tr>
<tr>
<td>6</td>
<td>PRODUCT_PACKAGES</td>
<td>系统需预装的一系列程序</td>
</tr>
<tr>
<td>7</td>
<td>PRODUCT_LOCALES</td>
<td>所支持的国家语言</td>
</tr>
<tr>
<td>8</td>
<td>PRODUCT_POLICY</td>
<td>本产品遵循的策略。例：android.policy_phone</td>
</tr>
<tr>
<td>9</td>
<td>PRODUCT_TAGS</td>
<td>产品 标签描述，以空格分隔</td>
</tr>
<tr>
<td></td>
<td>PRODUCT_PROPERTY_OVERRIDES</td>
<td>用于重载系统属性，存储在/system/build/.prop文件中。格式：key=value，例：ro.product.firmware=v0.4rc1</td>
</tr>
</tbody></table>
<h2 id="添加BoardConfig-mk文件"><a href="#添加BoardConfig-mk文件" class="headerlink" title="添加BoardConfig.mk文件"></a>添加BoardConfig.mk文件</h2><ol>
<li>目标架构</li>
<li>硬件设备属性</li>
<li>编译器的条件标志</li>
<li>分区布局</li>
<li>Boot地址</li>
<li>ramdisk大小</li>
</ol>
<h2 id="添加Android-mk"><a href="#添加Android-mk" class="headerlink" title="添加Android.mk"></a>添加Android.mk</h2><p>产品由很多模块组成，Android.mk是生产某个模块的“生产工序”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/1-android-%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/1-android-%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">原生态android 编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-13 21:08:48" itemprop="dateCreated datePublished" datetime="2020-12-13T21:08:48+08:00">2020-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-19 11:12:11" itemprop="dateModified" datetime="2020-11-19T11:12:11+08:00">2020-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于交叉编译"><a href="#关于交叉编译" class="headerlink" title="关于交叉编译"></a>关于交叉编译</h1><h2 id="什么是交叉编译？"><a href="#什么是交叉编译？" class="headerlink" title="什么是交叉编译？"></a>什么是交叉编译？</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>（1）目标平台由于种种原因（无法安装编译器，资源有限导致编译不正常）<br>（2）需要另外一个平台辅助生成可执行文件</p>
<p>平台是指？<br>平台=硬件+ 操作系统环境</p>
<h3 id="引出相关概念："><a href="#引出相关概念：" class="headerlink" title="引出相关概念："></a>引出相关概念：</h3><p>宿主机（host）：开发和编译代码所在平台<br>目标机（target）：宿主机编译生成的系统包就是提供给目标机使用的<br>交叉编译器（cross compiler）：本身在宿主机上运行，用于产生目标机可执行文件的编译器</p>
<h3 id="常用交叉编译器及应用环境"><a href="#常用交叉编译器及应用环境" class="headerlink" title="常用交叉编译器及应用环境"></a>常用交叉编译器及应用环境</h3><ol>
<li>在Windows PC上，利用ADS ARM开发环境，使用armcc编译器，可编译出针对ARMCPU的可执行代码。</li>
<li>在Linux PC上，利用arm-linux-gcc编译器，可编译出针对Linux ARM平台的可执行代码。</li>
<li>在Windows PC上，利用cygwin环境，运行arm-elf-gcc编译器，可编译出针对ARM CPU的可执行代码。</li>
<li>在Windows系统上，利用Keil Uvison工具，开发出运行在89C51单片机上的程序。</li>
<li>在Windows系统上，利用CodeWarrior IDE工具，开发出运行在Freescale XS128单片机上的程序。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>编译的环境和运行的环境是不一样，是属于交叉的，此所谓cross；</li>
</ol>
<h1 id="建立android编译环境"><a href="#建立android编译环境" class="headerlink" title="建立android编译环境"></a>建立android编译环境</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>宿主机：linux x86 pc<br>宿主机操作系统：ubuntu 14.04 LTS<br>交叉编译器：arm-linux-gcc<br>通用编译工具：<br>（1）python2.x<br>（2）GNU make 3.81-3.82<br>（3）JDK<br>（4）git 1.7以上版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装版本下载地址及相应安装命令如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><h3 id="step1-执行envsetup-sh"><a href="#step1-执行envsetup-sh" class="headerlink" title="step1: 执行envsetup.sh"></a>step1: 执行envsetup.sh</h3><p>envsetup.sh记录编译过程中所需的各种函数实现，如lunch ,mm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source .&#x2F;build&#x2F;envsetup.sh</span><br><span class="line">等价于</span><br><span class="line">. .&#x2F;build&#x2F;envsetup.sh</span><br></pre></td></tr></table></figure>
<h3 id="step2-选择编译目标"><a href="#step2-选择编译目标" class="headerlink" title="step2: 选择编译目标"></a>step2: 选择编译目标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<p>输入lunch后会弹出工程配置好的所有产品类型，我们再进行产品类型的选择</p>
<h3 id="step3：执行编译命令"><a href="#step3：执行编译命令" class="headerlink" title="step3：执行编译命令"></a>step3：执行编译命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>也可以充分利用cpu资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何编译出SDK？"><a href="#如何编译出SDK？" class="headerlink" title="如何编译出SDK？"></a>如何编译出SDK？</h3><h4 id="mac-os和linux下"><a href="#mac-os和linux下" class="headerlink" title="mac os和linux下"></a>mac os和linux下</h4><ol>
<li>下载源码</li>
<li>source ./build/envsetup.sh</li>
<li>lunch sdk-eng</li>
<li>make sdk</li>
</ol>
<h4 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h4><ol>
<li>在linux下生成sdk</li>
<li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mingw32 tofrodos</span><br></pre></td></tr></table></figure></li>
<li> 再次编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source .&#x2F;build&#x2F;envsetup.sh</span><br><span class="line">lunch sdk-eng</span><br><span class="line">make win_sdk</span><br></pre></td></tr></table></figure>













</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/13/22-%E7%AB%9E%E5%93%81%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/22-%E7%AB%9E%E5%93%81%E6%9C%BA/" class="post-title-link" itemprop="url">竞品机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-13 00:00:00 / 修改时间：22:59:23" itemprop="dateCreated datePublished" datetime="2020-12-13T00:00:00+08:00">2020-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th></th>
<th><a target="_blank" rel="noopener" href="https://product.pconline.com.cn/mobile/redmi/1286907.html">Redmi 9</a></th>
<th>Oppo A72 5G</th>
<th>华为畅想Z</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>799</td>
<td>1899</td>
<td>1599</td>
</tr>
<tr>
<td>发布时间</td>
<td>2020年,6月24日</td>
<td>2020年,7月25日</td>
<td>2020年夏季,5月24日</td>
</tr>
<tr>
<td>型号</td>
<td>Redmi9</td>
<td>A72</td>
<td>DVC-AN00</td>
</tr>
<tr>
<td>操作系统</td>
<td>Android  10</td>
<td>Android 10,ColorOS  7.2</td>
<td>Android  10</td>
</tr>
<tr>
<td>硬件参数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CPU品牌</td>
<td>联发科(MTK)</td>
<td>联发科(MTK)</td>
<td>联发科(MTK)</td>
</tr>
<tr>
<td>CPU</td>
<td>联发科Helio  G80</td>
<td>天玑720</td>
<td>联发科天玑800（MT6873）</td>
</tr>
<tr>
<td>CPU频率</td>
<td>6  * A55 1.8 GHz     2 * A75 2.0 Ghz</td>
<td>2  * A76 2.0GHz     6 * A55 2.0GHz</td>
<td>4  * A76 2.0GHz      4 * A55 2.0GHz</td>
</tr>
<tr>
<td>运行内存</td>
<td>4GB,6GB</td>
<td>8GB</td>
<td>6GB,8GB</td>
</tr>
<tr>
<td>机身容量</td>
<td>64GB,128GB</td>
<td>128GB</td>
<td>64GB,128GB</td>
</tr>
<tr>
<td>电池容量</td>
<td>5020mAh</td>
<td>4040mAh</td>
<td>4000mA</td>
</tr>
<tr>
<td>屏幕</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>屏幕大小</td>
<td>6.53英寸</td>
<td>6.5英寸</td>
<td>6.5英寸</td>
</tr>
<tr>
<td>屏幕分辨率</td>
<td>2340×1080像素(FHD+)</td>
<td>2400×1080像素</td>
<td>2400×1080像素</td>
</tr>
<tr>
<td>摄像头</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>摄像头类型</td>
<td>后置四摄像头,后置单摄</td>
<td>后置三摄像头,前置单摄像头</td>
<td>后置三摄像头,前置单摄</td>
</tr>
<tr>
<td>后置摄像头</td>
<td>1300万像素</td>
<td>1600万像素,主摄</td>
<td>4800万像素,主摄，F1.8光圈</td>
</tr>
<tr>
<td>后置摄像头2</td>
<td>800万像素,118°防畸变超广角镜头</td>
<td>800万像素,超广角摄像头</td>
<td>800万像素,广角摄像头，F2.4光圈</td>
</tr>
<tr>
<td>后置摄像头3</td>
<td>500万像素,微距镜头</td>
<td>200万像素,黑白摄像头</td>
<td>200万像素,微距摄像头，F2.4光圈</td>
</tr>
<tr>
<td>后置摄像头4</td>
<td>200万像素,景深镜头</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>后置摄像头光圈</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>前置摄像头</td>
<td>800万像素</td>
<td>800万像素</td>
<td>1600万像素</td>
</tr>
<tr>
<td>闪光灯</td>
<td></td>
<td></td>
<td>LED补光灯</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/12/06/21-ImageFormat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/06/21-ImageFormat/" class="post-title-link" itemprop="url">image</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-06 16:00:48" itemprop="dateCreated datePublished" datetime="2020-12-06T16:00:48+08:00">2020-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-13 21:27:10" itemprop="dateModified" datetime="2020-12-13T21:27:10+08:00">2020-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#图像有哪些格式？</p>
<ol>
<li>jpeg</li>
<li>bmp</li>
<li>png</li>
</ol>
<p>注：手机生成的图像格式大多为JPEG</p>
<blockquote>
<blockquote>
<p>YUV：luma(Y)+chroma(UV)格式（亮度、色度），一般情况下sensor支持YUV422格式，即Y-U-Y-V次序输出数据。</p>
</blockquote>
</blockquote>
<pre><code>&gt;&gt;RGB：传统的红绿蓝格式，比如RGB565,5bit R + 6bit G + 5bit B，G多一位是因为人眼对绿色比较敏感。

&gt;&gt;RAW RGB：sensor的每一像素对应一个彩色滤光片，滤光片按Bayer Pattern(拜耳模板)分布，将每一个像素的数据直接输出，即Raw RGB Data。

&gt;&gt;JPEG：有些sensor，特别是低分辨率的，其自带JPEG engine，可以直接输出压缩后的jpg格式的数据。

注意：

a&gt;YUV一个像素占2B，如果像素太大，在高时钟下基带芯片处理不过来，JPEG数据量就要小很多，因为基带芯片对输出数据的速率有要求，所以基带芯片低时钟下使用YUV sensor，高时钟下使用JPEG sensor。

b&gt;如果直接输出RGB，对于LCD显示是最方便的，但是大多数基带芯片都是要求输出为YUV格式的数据再进行，这是因为，YUV输出数据的亮度信号没有任何损失，而色偏信号人眼并不是特别敏感，RGB565输出格式是R5G3 G3B5，会丢失很多原始信息，所以YUV图像质量和稳定性要比RGB565好的多。因此，很低端的基带芯片上才会输出RGB565格式。

Raw和JPEG的区别：

Raw优点：

1&gt;Raw格式文件本质上是一个没有经过任何图像处理的源文件，它能原原本本地记录相机拍摄的信息，没有经过图像处理（锐化、色彩对比增强）和压缩而造成的信息丢失。相比之下，JPEG格式的数据经过压缩处理，无法完整的保存原图形的所有数据。

2&gt;Raw是一种专业摄影师常用的格式，因为它能原原本本地保存信息，让用户能大幅度进行后期制作，并且无论怎么操作，照片都能无损的恢复到最初状态；但是JPEG就弱了些，虽然因为PS等技术的发展，也可以在JPEG上进行后期制作，但是如果做大幅度的调整还是Raw文件比较合适。

3&gt;可以用专门的软件修正摄像机的不足，比如佳能DPP软件可以修正镜头失光、变形等。

Raw缺点：

1&gt;存储数据量太大，JPEG就小很多

2&gt;需要专门的软件来打开，JPEG几乎所有的PC都可以直接打开

3&gt;打开速度较慢，JPEG较快

4&gt;不同的软件有不同的方式去演绎RAW文件，所以在不同的软件上会有细微的差别。

5&gt;厂商卖的专用软件价格较高，而这方面JPEG几乎无成本</code></pre>
<p>##图像采集的过程<br>图像采集的过程为：光照在成像物体被反射 -&gt; 镜头汇聚 -&gt; Sensor光电转换-&gt; ADC转换为raw。</p>
<h3 id="sensor-感光原理"><a href="#sensor-感光原理" class="headerlink" title="sensor 感光原理"></a>sensor 感光原理</h3><ol>
<li>模组<br>摄像头模组，Camera Compact Module，简写为CCM，就是已经包含了镜头，ISP，PCB接口的直接能用的，不需要再考虑sensor选型，设计sensor供电电路，时钟电路的。<br><img src="3.png" alt="img"></li>
</ol>
<p>摄像头模组硬件结构图：<br><img src="4.png" alt="img"></p>
<p>光线通过镜头Lens进入摄像头内部，然后经过IR Filter过滤红外光，最后到达sensor（传感器），<strong>senor分为按照材质可以分为CMOS和CCD两种</strong>，可以将光学信号转换为电信号，再通过内部的ADC电路转换为数字信号，然后传输给DSP（如果有的话，如果没有则以DVP的方式传送数据到基带芯片baseband，此时的数据格式Raw Data，后面有讲进行加工）加工处理，转换成RGB、YUV等格式输出。</p>
<ol start="2">
<li>镜头 Lens：<br>镜头对成像有很重要的作用，相当于人眼中的晶状体，利用透镜的折射原理，景物光线透过镜头在聚焦平面上形成清晰的像，然后通过感光材料CMOS或CCD记录影像，并通过电路转换为电信号。镜头产业有比较高的技术门槛，国外主要集中在日本、韩国，国内主要是在台湾，业内比较知名的如：富士精机、柯尼卡美能达、大力光、Enplas等。</li>
</ol>
<p><img src="7.png" alt="img"><br>Lens一般由几片透镜组成透镜结构，按材质可分为塑胶透镜(plastic)或玻璃透镜(glass)，玻璃镜片比树脂镜片贵。塑胶透镜其实是树脂镜片，透光率和感光性等光学指标比不上镀膜镜片。通常摄像头采用的镜头结构有：1P、2P、1G1P、1G2P、2G2P、2G3P、4G、5G等。透镜越多，成本越高，相对成像效果会更出色（个人理解是光线更均匀、更细致；对光线的选通更丰富；成像畸变更小，但是会导致镜头变长，光通量变小）。</p>
<ol start="3">
<li><p>红外滤光片 IR Filter<br>主要是过滤掉进入镜头的光线中的红外光，这是因为人眼看不到红外光，但是sensor却能感受到红外光，所以需要将光线中的红外光滤掉，以便图像更接近人眼看到的效果。</p>
</li>
<li><p>传感器 Sensor<br>目前常用的sensor有两种，一种是CCD（电荷耦合）原件；一种是CMOS（金属氧化物导体）原件。</p>
</li>
</ol>
<blockquote>
<p>CCD（Charge Coupled Device），电荷耦合器件传感器：使用一种高感光度的半导体材料制成，能把光线转变成电荷，通过模数转换器芯片转换成电信号。CCD由许多独立的感光单位组成，通常以百万像素为单位。<strong>当CCD表面受到光照时，每个感光单位都会将电荷反映在组件上，所有的感光单位产生的信号加在一起，就构成了一幅完整的图像。</strong>CCD传感器以日本厂商为主导，全球市场上有90%被日本厂商垄断，索尼、松下、夏普是龙头。</p>
</blockquote>
<blockquote>
<p>CMOS（Complementary Metal-Oxide Semiconductor），互补性氧化金属半导体：主要是利用硅和锗做成的半导体，使其在CMOS上共存着带N(-)和P(+)级的半导体，这两个互补效应所产生的电流可以被处理芯片记录并解读成影像。CMOS传感器主要以美国、韩国和中国台湾为主导，主要生产厂家是美国的OmnVison、Agilent、Micron，中国台湾的锐像、原相、泰视等，韩国的三星、现代。</p>
</blockquote>
<ol start="5">
<li>图像处理芯片 DSP</li>
</ol>
<p>DSP是CCM的重要组成部分，它的作用是将感光芯片获得的数据及时地快速地传递到中央处理器并刷新感光芯片，因此DSP芯片的好坏，直接影响画面品质，如：色彩饱和度、清晰度、流畅度等。如果sensor没有集成DSP，则通过DVP的方式传输到baseband芯片中（可以理解为外挂DSP），进入DSP的数据是RAW Data，采集到的原始数据。如果集成了DSP，则RAW Data会经过AWB、color matrix、lens shading、gamma、sharpness、AE和de-noise处理，最终输出YUV或者RGB格式的数据。如下图中所示，ISP（Image Sensor Processor，不是Image Signal Processor）部分中使用的就是DSP来处理Image sensor的输出数据（Raw Data）：<br><img src="8.png" alt="img"></p>
<ol start="6">
<li><p>DVP<br>DVP分为三个部分：输出总线；输入总线；电源总线；如下图：<br><img src="9.png" alt="img"></p>
<blockquote>
<blockquote>
<p>输入总线介绍</p>
</blockquote>
</blockquote>
<p> a&gt;PWDN是camera的使能管脚，有两种配置方式，一种为standby，一种是normal work，设置为standby的时候，一切对camera的操作都是无效的，包括复位。所以在RESET之前，一定要将PWDN管脚设置为normal模式，否则RESET无效。</p>
<p> b&gt;RESET是camera的复位管脚，此方式为硬复位模式，camera的各个IO口恢复到出厂默认状态。只有在XCLK开启后，将RESET置为低，硬复位才有效，否则复位无效。</p>
<p> c&gt;XCLK是camera的工作时钟管脚，此管脚为BB提供camera的工作时钟。</p>
<p> d&gt;IIC是camera和BB通信的总线通道。</p>
<blockquote>
<blockquote>
<p>输出总线介绍</p>
</blockquote>
</blockquote>
<p> a&gt;data为camera的数据管脚。此数据脚可以输出的格式有YUV、RGB、JPEG等。</p>
<p> b&gt;VSYNC为camera的帧同步信号管脚。一个VYSNC信号结束表示一帧（即一个画面）的数据已经输出完毕。</p>
<p> c&gt;HSYNC为camera行同步信号管脚。一个HSYNC信号结束表示一行的数据已经输出完毕。</p>
<p> d&gt;PCLK为像素同步信号管脚。一个PCLK信号结束表示一个像素点的数据已经输出完毕。  </p>
<blockquote>
<blockquote>
<p>Power线介绍</p>
</blockquote>
</blockquote>
<p> a&gt;AVDD为camera的模拟电压。</p>
<p> b&gt;DOVDD为camera的GPIO口数字电压。</p>
<p> c&gt;DVDD为camera的核工作电压。<br>一般来说，要求先提供sensor的GPIO口电压，接着提供模拟电压，最后提供工作电压。时序如下图：<br><img src="10.png" alt="img"></p>
</li>
<li><p>FPC柔性电路板(柔性PCB)<br>简称”软板”, 又称”柔性线路板”,连接芯片和手机。起到电信号传输作用。</p>
</li>
<li><p>一些概念区别</p>
<blockquote>
<blockquote>
<p>常见基带处理器或者基带芯片负责数据处理与储存，相当于一个协处理器，主要组件为DSP、微控制器、内存（如SRAM、Flash）等单元，主要功能为基带编码/译码、声音编码及语音编码 等。目前主流基带架构：DSP+ARM。可分为五个子块：CPU处理器、信道编码器、DSP、调制解调器和接口模块。</p>
</blockquote>
</blockquote>
<p> 基带芯片是用来合成即将的发射的基带信号，或对接收到的基带信号进行解码。具体地说，就是：发射时，把音频信号编译成用来发射的基带码；接收时，把收到的基带码解译为音频信号。同时，也负责地址信息（手机号、网站地址）、文字信息（短讯文字、网站文字）、图片信息的编译。</p>
</li>
</ol>
<blockquote>
<blockquote>
<p>ISP，Image Signal Processor，图像信号处理器；DSP，Data Signal Processor，数字信号处理器。</p>
</blockquote>
</blockquote>
<pre><code>ISP一般用来处理Image Sensor（图像传感器）的输出数据，如进行：AEC（自动曝光控制）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Gamma校正、祛除坏点、Auto Black Level、Auto White Level 等等功能的处理。</code></pre>
<blockquote>
<blockquote>
<p>而DSP功能就比较多了，它可以做些拍照以及回显（JPEG的编解码）、录像以及回放（Video 的编解码）、H.264的编解码、还有很多其他方面的处理，总之是处理数字信号了。可以认为ISP是一类特殊的处理图像信号的DSP。</p>
</blockquote>
</blockquote>
<p>在摄像头这部分，要看清楚ISP表示的是什么，是Image Signal Processor（图像信号处理器），还是Image Sensor Processor（图像传感器处理器）。像上面的OV2665里面的ISP就是Image Sensor Processor，相当于Sensor模块中的一部分，由DSP做处理器。而下面的GC0308，则正好相反，是Image Signal Processor，是一个真正的处理器，所以在看到ISP的时候要根据语境看指的是一个具体的处理器还是模块的组成部分。<br><img src="11.png" alt="img"></p>
<ol start="9">
<li><p>图像解析度/分辨率(resolution)</p>
<table>
<thead>
<tr>
<th>QSIF/QQVGA</th>
<th>160 x 120</th>
<th>19200</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>QCIF</td>
<td>176 x 144</td>
<td>25344</td>
<td></td>
</tr>
<tr>
<td>SIF/QVGA</td>
<td>320 x 240</td>
<td>76800</td>
<td></td>
</tr>
<tr>
<td>CIF</td>
<td>352 x 288</td>
<td>101376</td>
<td>10万像素</td>
</tr>
<tr>
<td>VGA</td>
<td>640 x 480</td>
<td>307200</td>
<td>30万像素(35万是指648X488)</td>
</tr>
<tr>
<td>SVGA</td>
<td>800 x 600</td>
<td>480000</td>
<td>50万像素</td>
</tr>
<tr>
<td>XGA</td>
<td>1024 x 768</td>
<td>786438</td>
<td>80万像素</td>
</tr>
<tr>
<td>SXGA</td>
<td>1280 x 1024</td>
<td>1310720</td>
<td>130万像素</td>
</tr>
<tr>
<td>UXGA</td>
<td>1600 x 1200</td>
<td>1920000</td>
<td>200万像素</td>
</tr>
<tr>
<td>QXGA</td>
<td>2048 x 1536</td>
<td>3145728</td>
<td>300万像素(320W)</td>
</tr>
<tr>
<td>QSXGA</td>
<td>2592 x 1944</td>
<td>5038848</td>
<td>500万像素</td>
</tr>
<tr>
<td></td>
<td>2816 x 2112</td>
<td>2947392</td>
<td>600万像素</td>
</tr>
<tr>
<td></td>
<td>3072 x 2304</td>
<td>7077888</td>
<td>700万像素</td>
</tr>
<tr>
<td></td>
<td>3200 x 2400</td>
<td>7680000</td>
<td>770万像素</td>
</tr>
<tr>
<td></td>
<td>3264 x 2448</td>
<td>7990272</td>
<td>800万像素</td>
</tr>
<tr>
<td></td>
<td>3876 x 2584</td>
<td>10015584</td>
<td>1000万像素</td>
</tr>
</tbody></table>
</li>
<li><p>Sensor的感光原理<br>Sensor负责通过一个一个的感光点对光进行采样和量化，但，在Sensor中，每一个感光点只能感光RGB中的一种颜色。所以，通常所说的30万像素或130万像素等，指的是有30万或130万个感光点。<strong>每一个感光点只能感光一种颜色，一个感光点就是一个像素。</strong></p>
</li>
</ol>
<p>因为sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B，形成的数据就成为了raw数据。raw数据是sensor的经过光电转换后通过ADC采样后直接输出数据，是未经处理过的数据，表示sensor接受到的各种光的强度。</p>
<p>解释：sensor上是由一个个感光的小点（你可以这么理解，就是只有几个微米大小的感光器件组成，多少个感光小点就有多少个像素），但是一个像素上要采集多种最基本的颜色，如rgb三种颜色，最简单的方法就是用滤镜的方法，红色的滤镜透过红色的波长，绿色的滤镜透过绿色的波长，蓝色的滤镜透过蓝色的波长。如果要采集rgb三个基本色，则需要三块滤镜，这样价格昂贵，且不好制造，因为三块滤镜都必须保证每一个像素点都对齐显然是不可能的。</p>
<p>所以就有了bayer这种方式，<strong>bayer 格式图片在一块滤镜上设置的不同的颜色，</strong>通过分析人眼对颜色的感知发现，人眼对绿色比较敏感，所以一般bayer格式的图片绿色格式的像素是是r和g像素的和。</p>
<p>Bayer是相机内部的原始图片, 一般后缀名为.raw，bayer图一个像素就只有一个颜色, 或R或G或B。要还原一个真正图像，需要每一个点都有RGB三种颜色。RGB图, 即为三色图, 一个像素点就由RGB三种颜色构成的混合色。</p>
<p>在Sensor模组的内部会有一个ISP模块（应该理解为Image Sensor Processor，是Sensor模块的组成部分，），会对Sensor采集到的数据进行插值和特效处理。如果一个像素点感应为R值，那么ISP会根据该感光点周围的G、B的值，通过插值和特效处理等，计算出该R点的G、B值。</p>
<p>摄像头模组里面干了这个几件事</p>
<p>（1）sensor芯片需要的电源和时钟等信号的设计</p>
<p>（2）有些sensor自己就带内部ISP，或者说集成了，所以输出的直接是YUV或者RGB格式</p>
<p>（3）没有ISP的sensor就需要外部挂一个ISP。电路上就是一个sensor的信号连接到ISP上，信号和传输YUV的这种DVP信号很类似，但是传输的信息是完全不一样的。</p>
<p><img src="5.png" alt="img"></p>
<p>摄像头上有这几个参数，有效像素，和像素尺寸大小：</p>
<p><img src="6.png" alt="img"></p>
<p>对于不同的sensor，在其内部形成的raw数据格式也是有区别的。raw数据排列格式（Bayer pattern）有四种：</p>
<table>
<thead>
<tr>
<th>G</th>
<th>R</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>G</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>G</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>G</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>R</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>B</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>B</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>R</td>
</tr>
</tbody></table>
<p>假设一个sensor的像素是8<em>8（分辨率为8</em>8），那么这个sensor就有8*8个感光点，每个感光点就是一个晶体管。那么对于上表中四种排列格式的rawRGB数据如下图所示：</p>
<p><img src="2.png" alt="img"></p>
<p>由上图可以看出，每一种格式的rawRGB数据的G分量都是B、R分量的两倍，是因为人眼对于绿色的更加敏感，所以加重了其在感光点的权重，增加了对绿色信息的采样。)</p>
<h3 id="摄像头工作原理"><a href="#摄像头工作原理" class="headerlink" title="摄像头工作原理"></a>摄像头工作原理</h3><table>
<thead>
<tr>
<th>Signal</th>
<th>I/O</th>
<th>Description</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>HREF</td>
<td>I</td>
<td>行同步信号</td>
<td></td>
</tr>
<tr>
<td>PCLK</td>
<td>I</td>
<td>像素时钟</td>
<td></td>
</tr>
<tr>
<td>DATA[7:0]</td>
<td>I</td>
<td>像素数据</td>
<td></td>
</tr>
<tr>
<td>FIELD</td>
<td>O</td>
<td>FIELD信号</td>
<td></td>
</tr>
<tr>
<td>MCLK</td>
<td>O</td>
<td>系统时钟信号</td>
<td></td>
</tr>
<tr>
<td>每个摄像头都有三个时钟域，第一个是系统总线时钟域；第二个是摄像头像素时钟域PCLK；第三个是内部时钟MCLK。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>系统总线时钟必须高于PCLK，CAM_MCLK必须固定频率发呢拼比，如：PLL时钟。</p>
<p>一旦给摄像头提供了时钟，并且复位了摄像头，摄像头就可以工作了，通过PCLK、HSYNC、VSYNC听不传输数字图像信号。</p>
<pre><code>摄像头的驱动需要完成三大步：

&gt;&gt;摄像头的上电、时钟这些基本条件

&gt;&gt;IIC保证摄像头的初始化

&gt;&gt;摄像头工作后传回数据到主控</code></pre>
<p><img src="12.png" alt="img"></p>
<p>控制部分是摄像头上电、IIC控制接口；数据输出是摄像头拍摄的图像数据传到主控芯片，所以，需要有Data、行场同步时钟(告诉主控芯片哪些数据是一行，哪些是一帧)、以及时钟（PCLK，像素时钟，告诉主控芯片哪些数据是一个像素点）。<br>（1）、MCLK</p>
<pre><code>摄像头要 工作，必须要有个时钟进行同步，这个时钟就是MCLK，必须要有，否则摄像头就是一个死物，这个时钟由主控芯片提供，确切的说是有主控芯片的控制器提供，下面会提到。</code></pre>
<p>（2）、RESET</p>
<pre><code>复位信号，上面有提</code></pre>
<p>（3）、SDA、SCL</p>
<pre><code>IIC总线，主要作用就是为主控芯片配置或者读取摄像头的寄存器提供通道。mini2440音频模块中的L3协议，也是这个作用。不要看见协议就怕，协议就是一条路，数据传输的路，有规定的数据传输的道路。</code></pre>
<p><img src="13.png" alt="img"></p>
<p>4）、Configuration Register</p>
<pre><code>配置寄存器，控制器（在主控芯片中）通过IIC来设置，相当于告诉摄像头如何工作等。</code></pre>
<p>（5）、Timing Control</p>
<pre><code>时序控制，主要是根据主控芯片提供的MCLK时钟来控制行场同步、自动曝光AEC等。因为这些都需要时钟的配合。</code></pre>
<p>（6）、Pixel Array</p>
<pre><code>gc0308物理上的阵列是648H*492V，实际采样阵列是648H*488V，也是有效阵列。实际取像的阵列是640H*480V。如下图所示：</code></pre>
<p><img src="14.png" alt="img"></p>
<p>（7）、CDS</p>
<pre><code>Correlated Double Sampling，相关双联取样电路。CCD传感器的每个像素点输出波形只在一部分时间内是图像信号，其余时间是复位电平和干扰，为了提取图像信号并消除干扰，就要采用取样保持电路。</code></pre>
<p>（8）、Analog Processing、10bit ADC</p>
<pre><code>主要是将sensor得到的电信号转换为数字信号，方便ISP或者DSP处理。</code></pre>
<p>（9）、Image Signal Processing</p>
<pre><code>图像信号处理器，可以理解为DSP的一种，主要是对sensor经过ADC处理后的Raw Data进行处理，主要有自动白平衡AWB、插值计算（Bayer interpolation主要是对Raw Data进行格式转换，转为YUV /RGB等）、去噪、gamaa修正、色彩修正、边缘增强等。这些都是由寄存器决定，寄存器又是通过IIC总线来设置的。</code></pre>
<p>（10）、Output Mode &amp; Sync Control</p>
<p>** 输出接口，从光线进入镜头、过滤、光感应、ADC，然后到图像数据处理，最终数据到达外部接口。摄像头取一幅图像的整个工作完成，摄像头本质上还是一个终端节点，所以需要将采集好的图像数据传递给主控芯片，所以要有数据引脚，图形格式不是Raw Data，而是YUV或者RGB数据。进行数据传输，肯定需要时钟进行同步，所以需要PCLK，告诉主控芯片，哪个数据代表了一个像素点；VSYNC负责告诉芯片哪些是一帧数据，HSYNC则同步行数据。**</p>
<p>#jpeg文件是如何生成的？</p>
<ol>
<li>首先是要有光学信息。物体自己发光，或者反射光。</li>
<li>sensor(光信号感应器)，将光信号转换为数字信号。<br> input：光信号<br> output：数字信号，格式为raw</li>
<li>raw数据被送往ISP，先转换成RGB，再转换成YUV。</li>
<li>jpeg编码器将ISP输出的YUV数据进行编码压缩，最终输出jpeg文件。</li>
</ol>
<p><img src="1.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://queeniechen.github.io/2020/11/28/11-power-hint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Queenie Chen">
      <meta itemprop="description" content="我叫小白，初来乍到，请多指教~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Queenie Chen">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/11-power-hint/" class="post-title-link" itemprop="url">power hint机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-28 19:52:50" itemprop="dateCreated datePublished" datetime="2020-11-28T19:52:50+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-30 08:12:16" itemprop="dateModified" datetime="2020-11-30T08:12:16+08:00">2020-11-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>这里camera场景指camera执行的不同阶段，比如open ,preview, take picture.  不同场景对camera性能和功耗要求不一样，比如open时想要快速，必须提频，此时功耗也就高了。如何设置调节策略使得各场景既能达到想要的反应速度，流畅水平，又使得能耗消耗在预期水平？由此引入power hint 机制。</p>
<p>总结一下：性能和功耗平衡需要策略</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>不同的平台软、硬件配置不一样，性能不同，那么策略也有所不同。这里分为3个等级，分别是performance, normal, low power。</p>
<table>
<thead>
<tr>
<th>Power scene</th>
<th>CPU DVFS，</th>
<th>Thermal</th>
<th>DDR DFS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Performance</strong></td>
<td>Generally，at least 4 CPU online &amp; Freq is veryhigh</td>
<td>Disable</td>
<td>Very  high/Normal</td>
</tr>
<tr>
<td><strong>Normal</strong></td>
<td>Default</td>
<td>Enable</td>
<td>Very high/Normal/Low</td>
</tr>
<tr>
<td><strong>Low power</strong></td>
<td>Some  projects have cpu hotplug &amp; Increase the proportion of running low Freq</td>
<td>Enable</td>
<td>Very  high//Normal/Low</td>
</tr>
</tbody></table>
<ol>
<li>performance：<br> 1）通常，至少4个cpu online，cpu freq很高<br> 2）拔核策略disable<br> 3）ddr dfs为high或者normal</li>
<li>normal：<br> 1）cpu频点默认<br> 2）拔核策略enable<br> 3）ddr dfs：high/normal/low</li>
<li>low power：<br> 1)增加跑低频的概率<br> 2)拔核策略enable<br> 3)ddr dfs：high/normal/low</li>
</ol>
<p>##1.1 hal3_2v1<br>对于open camera, close camera, stop preview(flush)，走的都是perforemance等级，ddr dfs走normal即可。</p>
<p>take picture走performance，ddr dfs走high。</p>
<p>recording走low power,ddr dfs也是normal。</p>
<p>普通预览走low power,ddr dfs也是low。</p>
<p>bokeh预览走normal，ddr dfs也是normal。</p>
<table>
<thead>
<tr>
<th>Power scene</th>
<th>CPU DVFS，</th>
<th>Thermal</th>
<th>DDR DFS</th>
<th>Camera  scene</th>
</tr>
</thead>
<tbody><tr>
<td>Performance</td>
<td>Generally，at least 4 CPU online  &amp;  Freq is veryhigh</td>
<td>Disable</td>
<td>normal</td>
<td>Open/close  Camera，stop preview (flush)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Very High</td>
<td>Take  picture</td>
</tr>
<tr>
<td>Normal</td>
<td>Default</td>
<td>Enable</td>
<td>Normal</td>
<td>Preview  with Blu /Bokeh/Panorama</td>
</tr>
<tr>
<td>Low power</td>
<td>Some  projects have cpu hotplug /Increase the proportion of running low Freq</td>
<td>Enable</td>
<td>Normal</td>
<td>Recording</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Low</td>
<td>preview  under normal scene</td>
</tr>
</tbody></table>
<p><img src="1.png" alt="img"></p>
<p>##1.2 hal3_2v4</p>
<table>
<thead>
<tr>
<th>Power scene</th>
<th>CPU DVFS，</th>
<th>DDR DFS</th>
<th>Camera  scene</th>
</tr>
</thead>
<tbody><tr>
<td>Performance</td>
<td>Generally，at least 4 CPU online  &amp;  Freq is veryhigh</td>
<td>Normal（as default is Very high）</td>
<td>Open /close  Camera，</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Very high</td>
<td>Take  picture</td>
</tr>
<tr>
<td>Normal</td>
<td>Default</td>
<td>Normal （as default is Very high）</td>
<td>NULL</td>
</tr>
<tr>
<td>Low power</td>
<td>Just  Increase the proportion of running low Freq</td>
<td>Very high</td>
<td>Preview /  recording</td>
</tr>
</tbody></table>
<p><img src="2.png" alt="img"></p>
<h1 id="2-如何实现？"><a href="#2-如何实现？" class="headerlink" title="2. 如何实现？"></a>2. 如何实现？</h1><h2 id="2-1-怎么选择策略？"><a href="#2-1-怎么选择策略？" class="headerlink" title="2.1 怎么选择策略？"></a>2.1 怎么选择策略？</h2><p>各场景根据需要从如下的结构体中选择对应的策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef enum CAMERA_PERFORMACE_SCENE &#123;</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_1 &#x3D; 1,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_2,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_3,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_4,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_5,</span><br><span class="line">    CAM_PERFORMANCE_LEVEL_6,</span><br><span class="line">    CAM_PERFORMNCE_LEVEL_MAX</span><br><span class="line">&#125; sys_performance_camera_scene;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-setCamPreformaceScene"><a href="#2-1-1-setCamPreformaceScene" class="headerlink" title="2.1.1 setCamPreformaceScene"></a>2.1.1 setCamPreformaceScene</h3><p>问题来了，谁来选这个策略？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void SprdCameraSystemPerformance::setCamPreformaceScene(</span><br><span class="line">    sys_performance_camera_scene camera_scene) &#123;</span><br><span class="line">    Mutex::Autolock l(&amp;mLock);</span><br><span class="line">#ifndef CONFIG_CAMERA_DFS_FIXED_MAXLEVEL</span><br><span class="line">    switch (camera_scene) &#123;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_6:</span><br><span class="line">        setPowerHint(CAM_POWER_PERFORMACE_ON);</span><br><span class="line">        changeDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_5:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_4:</span><br><span class="line">        setPowerHint(CAM_POWER_NORMAL);</span><br><span class="line">        changeDfsPolicy(CAM_NORMAL);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_3:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_2:</span><br><span class="line">        setPowerHint(CAM_POWER_LOWPOWER_ON);</span><br><span class="line">        changeDfsPolicy(CAM_NORMAL);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_1:</span><br><span class="line">        setPowerHint(CAM_POWER_LOWPOWER_ON);</span><br><span class="line">        changeDfsPolicy(CAM_LOW);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGI(&quot;camera scene not support&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">#if (CONFIG_CAMERA_DFS_FIXED_MAXLEVEL &#x3D;&#x3D; 3)</span><br><span class="line">    changeDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">#elif(CONFIG_CAMERA_DFS_FIXED_MAXLEVEL &#x3D;&#x3D; 2)</span><br><span class="line">    changeDfsPolicy(CAM_NORMAL);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    switch (camera_scene) &#123;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_6:</span><br><span class="line">        setPowerHint(CAM_POWER_PERFORMACE_ON);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_5:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_4:</span><br><span class="line">        setPowerHint(CAM_POWER_NORMAL);</span><br><span class="line">        break;</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_3:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_2:</span><br><span class="line">    case CAM_PERFORMANCE_LEVEL_1:</span><br><span class="line">        setPowerHint(CAM_POWER_LOWPOWER_ON);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGI(&quot;camera scene not support&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    mCurrentPowerHintScene &#x3D; camera_scene;</span><br><span class="line"></span><br><span class="line">    HAL_LOGD(&quot;x camera scene:%d&quot;, camera_scene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又有2个问题，通过给函数setCamPreformaceScene传入具体参数camera_scene来选择策略，那么</p>
<ol>
<li>选择策略后，又是如何实现策略实施的呢？</li>
<li>谁给setCamPreformaceScene传的这个参数？</li>
</ol>
<h2 id="2-2-策略如何实施？"><a href="#2-2-策略如何实施？" class="headerlink" title="2.2 策略如何实施？"></a>2.2 策略如何实施？</h2><p>在setCamPreformaceScene这个函数体的实现中可以看到，根据不同配置有不同的策略方案。主要是：</p>
<ol>
<li>int SprdCameraSystemPerformance::changeDfsPolicy(dfs_policy_t dfs_policy)这个是来选择ddr dfs策略的</li>
<li>void SprdCameraSystemPerformance::setPowerHint(power_hint_state_type_t powerhint_id)这个是设置power hint的等级的</li>
</ol>
<p>ddr dfs等级结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum DFS_POLICY &#123;</span><br><span class="line">    CAM_EXIT,</span><br><span class="line">    CAM_LOW,</span><br><span class="line">    CAM_NORMAL,</span><br><span class="line">    CAM_VERYHIGH,</span><br><span class="line">&#125; dfs_policy_t;</span><br></pre></td></tr></table></figure>

<p>power scene结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef enum CURRENT_POWER_HINT &#123;</span><br><span class="line">    CAM_POWER_NORMAL,</span><br><span class="line">    CAM_POWER_PERFORMACE_ON,</span><br><span class="line">    CAM_POWER_PERFORMACE_ON</span><br><span class="line">&#125; power_hint_state_type_t;</span><br></pre></td></tr></table></figure>
<p>现在结构体是不是有点混乱？我们来理一理：<br>power_hint_state_type_t总共3个档次，对应之前说的NORMAL，PERFORMACE和PERFORMACE这3种策略。从表格中可以看出，不同的camera scene除了要选刚刚3种策略外，还要选中ddr dfs策略（这里dfs_policy_t有4档）。所以，由于cpu dvfs和ddr dfs都要选中，于是sys_performance_camera_scene就配出了多个来，这里是7个。实际代码实现顺序是先传camera_scene这个参数，再去适配cpu dvfs和ddr dfs。</p>
<h3 id="2-2-1-changeDfsPolicy"><a href="#2-2-1-changeDfsPolicy" class="headerlink" title="2.2.1 changeDfsPolicy"></a>2.2.1 changeDfsPolicy</h3><p>changeDfsPolicy这个函数是用来实现dfs_policy的选择的，当dfs_policy为CAM_EXIT时，根据当前dfs策略进行releaseDfsPolicy（mCameraDfsPolicyCur），设置完后将mCameraDfsPolicyCur = CAM_EXIT；当dfs_policyCAM_LOW时，setDfsPolicy（CAM_LOW），并且根据当前mCameraDfsPolicyCur来选择releaseDfsPolicy（）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">int SprdCameraSystemPerformance::changeDfsPolicy(dfs_policy_t dfs_policy) &#123;</span><br><span class="line"></span><br><span class="line">    switch (dfs_policy) &#123;</span><br><span class="line">    case CAM_EXIT:</span><br><span class="line">        if (CAM_LOW &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            releaseDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_NORMAL &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            releaseDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125; else if (CAM_VERYHIGH &#x3D;&#x3D; mCameraDfsPolicyCur)</span><br><span class="line">            releaseDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_EXIT;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_LOW:</span><br><span class="line">        if (CAM_EXIT &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_NORMAL &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_LOW);</span><br><span class="line">            releaseDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125; else if (CAM_VERYHIGH &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_LOW);</span><br><span class="line">            releaseDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        &#125;</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_LOW;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_NORMAL:</span><br><span class="line">        if (CAM_EXIT &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125; else if (CAM_LOW &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_NORMAL);</span><br><span class="line">            releaseDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_VERYHIGH &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_NORMAL);</span><br><span class="line">            releaseDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        &#125;</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_NORMAL;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_VERYHIGH:</span><br><span class="line">        if (CAM_EXIT &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">        &#125; else if (CAM_LOW &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">            releaseDfsPolicy(CAM_LOW);</span><br><span class="line">        &#125; else if (CAM_NORMAL &#x3D;&#x3D; mCameraDfsPolicyCur) &#123;</span><br><span class="line">            setDfsPolicy(CAM_VERYHIGH);</span><br><span class="line">            releaseDfsPolicy(CAM_NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        mCameraDfsPolicyCur &#x3D; CAM_VERYHIGH;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGW(&quot;unrecognize dfs policy&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;mCameraDfsPolicyCur: %d&quot;, mCameraDfsPolicyCur);</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-1-releaseDfsPolicy"><a href="#2-2-1-1-releaseDfsPolicy" class="headerlink" title="2.2.1.1 releaseDfsPolicy"></a>2.2.1.1 releaseDfsPolicy</h4><p>在releaseDfsPolicy（）这个函数里，根据不同的dfs_policy，设置dfs_scene值，并将其写入文件节点exit_scene</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int SprdCameraSystemPerformance::releaseDfsPolicy(int dfs_policy) &#123;</span><br><span class="line"></span><br><span class="line">    const char *dfs_scene &#x3D; NULL;</span><br><span class="line">    const char *const scenario_dfs &#x3D;</span><br><span class="line">        &quot;&#x2F;sys&#x2F;class&#x2F;devfreq&#x2F;scene-frequency&#x2F;sprd_governor&#x2F;exit_scene&quot;;</span><br><span class="line">    FILE *fp &#x3D; fopen(scenario_dfs, &quot;wb&quot;);</span><br><span class="line">    if (NULL &#x3D;&#x3D; fp) &#123;</span><br><span class="line">        HAL_LOGW(&quot;failed to open %s X&quot;, scenario_dfs);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (dfs_policy) &#123;</span><br><span class="line">    case CAM_LOW:</span><br><span class="line">        dfs_scene &#x3D; CAM_LOW_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_NORMAL:</span><br><span class="line">        dfs_scene &#x3D; CAM_NORMAL_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_VERYHIGH:</span><br><span class="line">        dfs_scene &#x3D; CAM_VERYHIGH_STR;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGW(&quot;unrecognize dfs policy&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;release dfs_scene: %s&quot;, dfs_scene);</span><br><span class="line">    &#x2F;&#x2F; echo dfs_scene &gt; scenario_dfs</span><br><span class="line">    fprintf(fp, &quot;%s&quot;, dfs_scene);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp &#x3D; NULL;</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-2-setDfsPolicy"><a href="#2-2-1-2-setDfsPolicy" class="headerlink" title="2.2.1.2 setDfsPolicy"></a>2.2.1.2 setDfsPolicy</h4><p>在 setDfsPolicy（）这个函数里，根据不同的dfs_policy，设置dfs_scene值，并将其写入文件节点scenario_dfs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int SprdCameraSystemPerformance::setDfsPolicy(int dfs_policy) &#123;</span><br><span class="line"></span><br><span class="line">    const char *dfs_scene &#x3D; NULL;</span><br><span class="line">    const char *const scenario_dfs &#x3D;</span><br><span class="line">        &quot;&#x2F;sys&#x2F;class&#x2F;devfreq&#x2F;scene-frequency&#x2F;sprd_governor&#x2F;scenario_dfs&quot;;</span><br><span class="line">    FILE *fp &#x3D; fopen(scenario_dfs, &quot;wb&quot;);</span><br><span class="line">    if (NULL &#x3D;&#x3D; fp) &#123;</span><br><span class="line">        HAL_LOGW(&quot;failed to open %s X&quot;, scenario_dfs);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (dfs_policy) &#123;</span><br><span class="line">    case CAM_LOW:</span><br><span class="line">        dfs_scene &#x3D; CAM_LOW_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_NORMAL:</span><br><span class="line">        dfs_scene &#x3D; CAM_NORMAL_STR;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_VERYHIGH:</span><br><span class="line">        dfs_scene &#x3D; CAM_VERYHIGH_STR;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGW(&quot;unrecognize dfs policy&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;dfs_scene: %s&quot;, dfs_scene);</span><br><span class="line">    &#x2F;&#x2F; echo dfs_scene &gt; scenario_dfs</span><br><span class="line">    fprintf(fp, &quot;%s&quot;, dfs_scene);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-setPowerHint"><a href="#2-2-2-setPowerHint" class="headerlink" title="2.2.2 setPowerHint"></a>2.2.2 setPowerHint</h3><p>setPowerHint函数的实现，首先要考虑和判断当前powerhint策略。例如要设置成CAM_POWER_PERFORMACE_ON，而当前已经是CAM_POWER_PERFORMACE_ON了，就无需多做什么了。若当前策略为CAM_POWER_NORMAL，而目标等级CAM_POWER_PERFORMACE_ON，则</p>
<p>1）acquirePowerHint</p>
<p>2）重新设置mCurrentPowerHint</p>
<p>当前策略不是CAM_POWER_NORMAL时，而策略有变化时，需要先releasePowerHint当前策略，再获取策略，置状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void SprdCameraSystemPerformance::setPowerHint(</span><br><span class="line">    power_hint_state_type_t powerhint_id) &#123;</span><br><span class="line"></span><br><span class="line">    if (!mPowermanageInited) &#123;</span><br><span class="line">        HAL_LOGE(&quot;need init.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_LOGD(&quot;IN, mCurrentPowerHint&#x3D;%d&quot;, mCurrentPowerHint);</span><br><span class="line"></span><br><span class="line">#if (CONFIG_HAS_CAMERA_HINTS_VERSION &#x3D;&#x3D; ANDROID_VERSION_P)</span><br><span class="line">    switch (mCurrentPowerHint) &#123;</span><br><span class="line">    case CAM_POWER_NORMAL:</span><br><span class="line">        if (powerhint_id &#x3D;&#x3D; CAM_POWER_PERFORMACE_ON) &#123;</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(false);</span><br><span class="line">            acquirePowerHint(mScenePerformance);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_PERFORMACE_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_LOWPOWER_ON) &#123;</span><br><span class="line">            acquirePowerHint(mSceneLowPower);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_LOWPOWER_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_NORMAL) &#123;</span><br><span class="line">            HAL_LOGD(&quot;current power state is already CAM_POWER_NORMAL,&quot;</span><br><span class="line">                     &quot;state are both 0, just return&quot;);</span><br><span class="line">            goto exit;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_POWER_PERFORMACE_ON:</span><br><span class="line">        if (powerhint_id &#x3D;&#x3D; CAM_POWER_PERFORMACE_ON) &#123;</span><br><span class="line">            HAL_LOGD(&quot;current power state is already CAM_POWER_PERFORMACE_ON,&quot;</span><br><span class="line">                     &quot;state are both 1, just return&quot;);</span><br><span class="line">            goto exit;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_LOWPOWER_ON) &#123;</span><br><span class="line">            releasePowerHint(mScenePerformance);</span><br><span class="line">            acquirePowerHint(mSceneLowPower);</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(true);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_LOWPOWER_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_NORMAL) &#123;</span><br><span class="line">            releasePowerHint(mScenePerformance);</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(true);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_NORMAL;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case CAM_POWER_LOWPOWER_ON:</span><br><span class="line">        if (powerhint_id &#x3D;&#x3D; CAM_POWER_PERFORMACE_ON) &#123;</span><br><span class="line">            &#x2F;&#x2F; thermalEnabled(false);</span><br><span class="line">            releasePowerHint(mSceneLowPower);</span><br><span class="line">            acquirePowerHint(mScenePerformance);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_PERFORMACE_ON;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_LOWPOWER_ON) &#123;</span><br><span class="line">            HAL_LOGD(&quot;current power state is already CAM_POWER_LOWPOWER_ON,&quot;</span><br><span class="line">                     &quot;state are both 0, just return&quot;);</span><br><span class="line">            goto exit;</span><br><span class="line">        &#125; else if (powerhint_id &#x3D;&#x3D; CAM_POWER_NORMAL) &#123;</span><br><span class="line">            releasePowerHint(mSceneLowPower);</span><br><span class="line">            mCurrentPowerHint &#x3D; CAM_POWER_NORMAL;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        HAL_LOGE(&quot;should not be here&quot;);</span><br><span class="line">        goto exit;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">exit:</span><br><span class="line">    HAL_LOGD(&quot;out, mCurrentPowerHint&#x3D;%d&quot;, mCurrentPowerHint);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-1acquirePowerHint"><a href="#2-2-2-1acquirePowerHint" class="headerlink" title="2.2.2.1acquirePowerHint"></a>2.2.2.1acquirePowerHint</h4><p>acquirePowerHint主要由acquire()实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if (CONFIG_HAS_CAMERA_HINTS_VERSION &#x3D;&#x3D; ANDROID_VERSION_P)</span><br><span class="line">void SprdCameraSystemPerformance::acquirePowerHint(</span><br><span class="line">    ::android::sp&lt;::android::PowerHintScene&gt; mScene) &#123;</span><br><span class="line"></span><br><span class="line">    if (mScene !&#x3D; NULL) &#123;</span><br><span class="line">        mScene-&gt;acquire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-2-releasePowerHint"><a href="#2-2-2-2-releasePowerHint" class="headerlink" title="2.2.2.2 releasePowerHint"></a>2.2.2.2 releasePowerHint</h4><p>releasePowerHint主要由release()实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void SprdCameraSystemPerformance::releasePowerHint(</span><br><span class="line">    ::android::sp&lt;::android::PowerHintScene&gt; mScene) &#123;</span><br><span class="line"></span><br><span class="line">    if (mScene !&#x3D; NULL) &#123;</span><br><span class="line">        mScene-&gt;release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="谁来选择策略？"><a href="#谁来选择策略？" class="headerlink" title="谁来选择策略？"></a>谁来选择策略？</h2><p>我们来看看哪些地方调用了setCamPreformaceScene：</p>
<ol>
<li><p>关闭相机的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SprdCamera3HWI::closeCamera() &#123;</span><br><span class="line">mOEMIf-&gt;setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>切换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int SprdCamera3HWI::flush() &#123;</span><br><span class="line">    if (mOEMIf) &#123;</span><br><span class="line">        mOEMIf-&gt;setFlushFlag(1);</span><br><span class="line">        mOEMIf-&gt;setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int SprdCamera3OEMIf::start(camera_channel_type_t channel_type,</span><br><span class="line">                            uint32_t frame_number) &#123;</span><br><span class="line">	setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动对焦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t SprdCamera3OEMIf::autoFocus() &#123;</span><br><span class="line">    if (mSysPerformace) &#123;</span><br><span class="line">        mGetLastPowerHint &#x3D; mSysPerformace-&gt;mCurrentPowerHintScene;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收预览帧时，根据预览流，当时的模式选择不同的档次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void SprdCamera3OEMIf::receivePreviewFrame(struct camera_frame_type *frame) &#123;</span><br><span class="line">	if (pre_stream) &#123;</span><br><span class="line">		if (!isCapturing() &amp;&amp; mIsPowerhintWait &amp;&amp; !mIsAutoFocus) &#123;</span><br><span class="line">			if ((frame_num &gt; mStartFrameNum) &amp;&amp;(frame_num - 						mStartFrameNum &gt; CAM_POWERHINT_WAIT_COUNT)) &#123;</span><br><span class="line">				if (getMultiCameraMode() &#x3D;&#x3D; MODE_BLUR ||</span><br><span class="line">                    getMultiCameraMode() &#x3D;&#x3D; MODE_BOKEH ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_PANORAMA ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_3DNR_PHOTO ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_FILTER ||</span><br><span class="line">                    mSprdAppmodeId &#x3D;&#x3D; -1 ||</span><br><span class="line">                    (mRecordingMode &amp;&amp; !mVideoWidth &amp;&amp; !mVideoHeight))&#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_4);</span><br><span class="line">				&#125; else if (mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_CONTINUE ||</span><br><span class="line">                           sprddefInfo-&gt;slowmotion &gt; 1) &#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);&#x2F;&#x2F;</span><br><span class="line">				&#125; else if (mRecordingMode &#x3D;&#x3D; true) &#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_3);&#x2F;&#x2F;录像模式</span><br><span class="line">				&#125; else if (getMultiCameraMode() !&#x3D; 											MODE_SINGLE_FACEID_UNLOCK) &#123;</span><br><span class="line">                    setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_1);</span><br><span class="line">                &#125;</span><br><span class="line">                mIsPowerhintWait &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接收jpeg图片时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void SprdCamera3OEMIf::receiveJpegPicture(struct camera_frame_type *frame) &#123;</span><br><span class="line">    if (getMultiCameraMode() &#x3D;&#x3D; MODE_BLUR ||</span><br><span class="line">        getMultiCameraMode() &#x3D;&#x3D; MODE_BOKEH ||</span><br><span class="line">        mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_3DNR_PHOTO) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_4);</span><br><span class="line">    &#125; else if (mRecordingMode &#x3D;&#x3D; true) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_3);</span><br><span class="line">    &#125; else if (mSprdAppmodeId &#x3D;&#x3D; CAMERA_MODE_CONTINUE) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void SprdCamera3OEMIf::HandleFocus(enum camera_cb_type cb, void *parm4) &#123;</span><br><span class="line">switch (cb) &#123;</span><br><span class="line">    case CAMERA_EXIT_CB_DONE:</span><br><span class="line">        HAL_LOGV(&quot;camera cb: autofocus succeeded.&quot;);</span><br><span class="line">        &#123;</span><br><span class="line">            if (mIsAutoFocus) &#123;</span><br><span class="line">                setCamPreformaceScene(mGetLastPowerHint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    case CAMERA_EXIT_CB_FAILED: &#123;</span><br><span class="line">        if (mIsAutoFocus) &#123;</span><br><span class="line">            setCamPreformaceScene(mGetLastPowerHint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SprdCamera3OEMIf::SprdCamera3OEMIf(int cameraId, SprdCamera3Setting *setting)</span><br><span class="line">    : mSetCapRatioFlag(false), mVideoCopyFromPreviewFlag(false),</span><br><span class="line">      mSprdPipVivEnabled(0), mSprdHighIsoEnabled(0), mSprdFullscanEnabled(0),</span><br><span class="line">      mSprdRefocusEnabled(0), mSprd3dCalibrationEnabled(0), mSprdYuvCallBack(0),</span><br><span class="line">      mSprdMultiYuvCallBack(0), mSprdReprocessing(0), mNeededTimestamp(0),</span><br><span class="line">      mIsUnpopped(false), mIsBlur2Zsl(false),</span><br><span class="line">      mPreviewFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mVideoFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mCallbackFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mPictureFormat(CAM_IMG_FMT_YUV420_NV21),</span><br><span class="line">      mRawFormat(CAM_IMG_FMT_BAYER_MIPI_RAW), mPreviewStartFlag(0),</span><br><span class="line">      mIsDvPreview(0), mIsStoppingPreview(0), mRecordingMode(0),</span><br><span class="line">      mIsSetCaptureMode(false), mRecordingFirstFrameTime(0), mUser(0),</span><br><span class="line">      mPreviewWindow(NULL), mHalOem(NULL), mIsStoreMetaData(false),</span><br><span class="line">      mIsFreqChanged(false), mCameraId(cameraId), miSPreviewFirstFrame(1),</span><br><span class="line">      mCaptureMode(CAMERA_NORMAL_MODE), mCaptureRawMode(0), mFlashMask(false),</span><br><span class="line">      mReleaseFLag(false), mTimeCoeff(1), mIsPerformanceTestable(false),</span><br><span class="line">      mIsAndroidZSL(false), mSetting(setting), BurstCapCnt(0), mCapIntent(0),</span><br><span class="line">      mPrvTimerID(NULL), mFlashMode(-1), mIsAutoFocus(false),</span><br><span class="line">      mIspToolStart(false), mSubRawHeapNum(0), mGraphicBufNum(0), mEisGraphicBufNum(0),</span><br><span class="line">      mSubRawHeapSize(0), mPathRawHeapNum(0), mPathRawHeapSize(0),</span><br><span class="line">      mPreviewDcamAllocBufferCnt(0), mIsRecording(false),</span><br><span class="line">      mZSLModeMonitorMsgQueHandle(0), mZSLModeMonitorInited(0), mCNRMode(0),</span><br><span class="line">      mGyroInit(0), mGyroExit(0), mEisPreviewInit(false), mEisVideoInit(false),</span><br><span class="line">      mGyroNum(0), mSprdEisEnabled(false), mVideoSnapshotType(0),</span><br><span class="line">      mIommuEnabled(false), mFlashCaptureFlag(0),</span><br><span class="line">      mFlashCaptureSkipNum(FLASH_CAPTURE_SKIP_FRAME_NUM), mFixedFpsEnabled(0),</span><br><span class="line">      mSprdAppmodeId(-1), mTempStates(CAMERA_NORMAL_TEMP), mIsTempChanged(0),</span><br><span class="line">      mFlagOffLineZslStart(0), mZslSnapshotTime(0), mIsIspToolMode(0),</span><br><span class="line">      mIsUltraWideMode(false), mIsRawCapture(0), mIsCameraClearQBuf(0),</span><br><span class="line">      mLatestFocusDoneTime(0), mFaceDetectStartedFlag(0),</span><br><span class="line">      mIsJpegWithBigSizePreview(0)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    SprdCameraSystemPerformance::getSysPerformance(&amp;mSysPerformace);</span><br><span class="line">    if (mSysPerformace) &#123;</span><br><span class="line">        setCamPreformaceScene(CAM_PERFORMANCE_LEVEL_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Queenie Chen</p>
  <div class="site-description" itemprop="description">我叫小白，初来乍到，请多指教~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Queenie Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
